import { ConfigPlugin } from "./ConfigPlugin";

/**
 * TOML configuration plugin (requires smol-toml dependency)
 * This plugin is optional and only loaded when TOML support is needed
 */
export class TomlConfigPlugin extends ConfigPlugin {
  readonly supportedExtensions = [".toml", ".tml"];
  readonly name = "toml";

  private tomlModule: any = null;

  constructor(tomlModule?: any) {
    super();
    if (tomlModule) {
      this.tomlModule = tomlModule;
    } else {
      this.loadTomlModule();
    }
  }

  private loadTomlModule(): void {
    try {
      // Dynamic import to avoid bundling issues
      if (typeof require !== "undefined") {
        this.tomlModule = require("smol-toml");
      } else {
        // For ESM environments, we need to use dynamic import
        // This will be handled asynchronously in the factory function
        throw new Error("TOML module not available in this environment");
      }
    } catch (error) {
      throw new Error(
        "TOML plugin requires smol-toml dependency. " +
          "Install it with: npm install smol-toml",
      );
    }
  }

  parse(content: string): Record<string, any> {
    if (!this.tomlModule) {
      // Fallback to simple parsing if module not available
      return this.parseTomlSimple(content);
    }

    try {
      const parsed = this.tomlModule.parse(content);
      if (typeof parsed !== "object" || parsed === null) {
        throw new Error("TOML file must contain an object at the root level");
      }
      return parsed;
    } catch (error) {
      throw new Error(
        `Failed to parse TOML: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  generate(
    _config: Record<string, any>,
    flags: any[],
    parsedArgs: any,
  ): string {
    const lines: string[] = [];
    lines.push("# Environment configuration generated by ArgParser");
    lines.push("# Format: TOML");
    lines.push("");

    const configWithValues: Record<string, any> = {};

    for (const flag of flags) {
      if (flag.name === "help") continue;

      const flagValue = parsedArgs[flag.name];
      const isSet = flagValue !== undefined && flagValue !== null;
      const isMandatory = flag.mandatory === true;

      lines.push(`# ${flag.description || flag.name}`);
      lines.push(`# Type: ${this.getTypeString(flag.type)}`);

      if (flag.defaultValue !== undefined) {
        lines.push(`# Default: ${flag.defaultValue}`);
      }

      if (isSet) {
        configWithValues[flag.name] = flagValue;
      } else if (isMandatory) {
        configWithValues[flag.name] =
          flag.defaultValue !== undefined ? flag.defaultValue : null;
      }

      lines.push("");
    }

    if (!this.tomlModule) {
      // Simple TOML generation if module not available
      for (const [key, value] of Object.entries(configWithValues)) {
        if (typeof value === "string") {
          lines.push(`${key} = "${value}"`);
        } else {
          lines.push(`${key} = ${JSON.stringify(value)}`);
        }
      }
      return lines.join("\n");
    }

    try {
      const tomlContent = this.tomlModule.stringify(configWithValues);
      return lines.join("\n") + "\n" + tomlContent;
    } catch (error) {
      throw new Error(
        `Failed to generate TOML: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Simple TOML parsing fallback for basic key-value pairs
   */
  private parseTomlSimple(content: string): Record<string, any> {
    const config: Record<string, any> = {};
    const lines = content.split("\n");

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith("#")) {
        const equalIndex = trimmed.indexOf("=");
        if (equalIndex > 0) {
          const key = trimmed.substring(0, equalIndex).trim();
          let value = trimmed.substring(equalIndex + 1).trim();

          // Remove quotes if present
          if (
            (value.startsWith('"') && value.endsWith('"')) ||
            (value.startsWith("'") && value.endsWith("'"))
          ) {
            value = value.slice(1, -1);
          }

          config[key] = value;
        }
      }
    }

    return config;
  }

  private getTypeString(type: any): string {
    if (typeof type === "function") {
      return type.name || "custom function";
    }
    return String(type).toLowerCase();
  }
}

/**
 * Factory function to create TOML plugin safely
 * Returns null if TOML dependency is not available
 */
export function createTomlPlugin(): TomlConfigPlugin | null {
  try {
    return new TomlConfigPlugin();
  } catch (error) {
    console.warn(
      "TOML plugin not available:",
      error instanceof Error ? error.message : String(error),
    );
    return null;
  }
}

/**
 * Async factory function to create TOML plugin with ESM support
 * Returns null if TOML dependency is not available
 */
export async function createTomlPluginAsync(): Promise<TomlConfigPlugin | null> {
  try {
    // Try CommonJS first
    if (typeof require !== "undefined") {
      try {
        const tomlModule = require("smol-toml");
        return new TomlConfigPlugin(tomlModule);
      } catch (error) {
        // Fall through to ESM import
      }
    }

    // Try ESM dynamic import
    const tomlModule = await import("smol-toml");
    return new TomlConfigPlugin(tomlModule);
  } catch (error) {
    console.warn(
      "TOML plugin not available:",
      error instanceof Error ? error.message : String(error),
    );
    return null;
  }
}
