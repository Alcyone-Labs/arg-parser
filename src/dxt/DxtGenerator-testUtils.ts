import * as fs from "node:fs";
import * as path from "node:path";
import type { ParseResult } from "../core/types";

/**
 * Test utilities for DxtGenerator
 * Contains methods that are only used during testing
 */
export class DxtGeneratorTestUtils {
  private argParserInstance: any;
  private extractMcpServerInfo: () => any;
  private handleExit: (
    exitCode: number,
    message?: string,
    type?: ParseResult["type"],
    data?: any,
  ) => ParseResult | never;

  constructor(
    argParserInstance: any,
    extractMcpServerInfo: () => any,
    handleExit: (
      exitCode: number,
      message?: string,
      type?: ParseResult["type"],
      data?: any,
    ) => ParseResult | never,
  ) {
    this.argParserInstance = argParserInstance;
    this.extractMcpServerInfo = extractMcpServerInfo;
    this.handleExit = handleExit;
  }

  /**
   * Handles DXT generation in test mode by creating mock DXT package structure
   * This method creates simplified mock files for testing purposes
   */
  public async handleTestModeDxtGeneration(
    processArgs: string[],
    buildDxtIndex: number,
  ): Promise<ParseResult> {
    try {
      // Get output directory from arguments (test mode expects directory argument)
      const outputDir = processArgs[buildDxtIndex + 1] || "./dxt-packages";

      // Check if we have MCP configuration
      const mcpTools = this.argParserInstance.toMcpTools();
      if (mcpTools.length === 0) {
        return this.handleExit(0, "No MCP servers found", "success");
      }

      // Extract server info from the unified MCP configuration
      const serverInfo = this.extractMcpServerInfo();

      // Create mock DXT package structure for testing
      const folderName = `${serverInfo.name.replace(/[^a-zA-Z0-9_-]/g, "_")}-dxt`;
      const buildDir = path.join(outputDir, folderName);

      // Ensure build directory exists
      if (!fs.existsSync(buildDir)) {
        fs.mkdirSync(buildDir, { recursive: true });
      }

      // Create mock manifest.json with DXT-compliant structure
      const manifest = {
        dxt_version: "0.1",
        name: serverInfo.name,
        version: serverInfo.version,
        description: serverInfo.description,
        author: serverInfo.author,
        server: {
          type: "node",
          entry_point: "server/index.mjs",
          mcp_config: {
            command: "node",
            args: ["${__dirname}/server/index.mjs", "--s-mcp-serve"],
            env: {},
          },
        },
        tools: mcpTools.map((tool: any) => ({
          name: tool.name,
          description: tool.description,
        })),
        icon: "logo.jpg",
      };

      fs.writeFileSync(
        path.join(buildDir, "manifest.json"),
        JSON.stringify(manifest, null, 2),
      );

      // Create mock package.json
      const packageJson = {
        name: serverInfo.name,
        version: serverInfo.version,
        description: serverInfo.description,
        main: "index.mjs",
        type: "module",
      };
      fs.writeFileSync(
        path.join(buildDir, "package.json"),
        JSON.stringify(packageJson, null, 2),
      );

      // Create mock README.md
      const readme = `# ${serverInfo.name}\n\n${serverInfo.description}\n\nGenerated by @alcyone-labs/arg-parser`;
      fs.writeFileSync(path.join(buildDir, "README.md"), readme);

      // Create mock build script
      const buildScript = `#!/bin/bash\necho "Mock DXT build script for ${serverInfo.name}"`;
      fs.writeFileSync(
        path.join(buildDir, "build-dxt-package.sh"),
        buildScript,
      );

      return this.handleExit(0, "DXT package generation completed", "success", {
        entryPoint: "test-mode",
        outputDir: buildDir,
      });
    } catch (error) {
      return this.handleExit(
        1,
        `Test mode DXT generation failed: ${error instanceof Error ? error.message : String(error)}`,
        "error",
      );
    }
  }

  /**
   * Checks if the current environment is in test mode
   * Used to determine whether to use test utilities or production code
   */
  public static isTestMode(): boolean {
    return (
      process.env["NODE_ENV"] === "test" ||
      process.argv[0]?.includes("vitest") ||
      process.argv[1]?.includes("vitest") ||
      process.argv[1]?.includes("tinypool")
    );
  }
}
