{"version":3,"file":"index.mjs","sources":["../__vite-browser-external","../src/types.ts","../src/FlagManager.ts","../src/ArgParser.ts"],"sourcesContent":["export default {}","import { z } from 'zod';\n\n// Forward declaration for ArgParser to avoid circular dependency in HandlerContext\n// This will be replaced or refined once ArgParser.ts is updated to use these types.\ntype ArgParserInstance = any;\n\nexport const zodFlagSchema = z\n  .object({\n    name: z\n      .string()\n      .min(1, \"Flag name cannot be empty\")\n      .describe(\n        \"The output property name, used as a return key `{name: value}`. Must be unique.\",\n      ),\n    allowLigature: z\n      .boolean()\n      .default(true)\n      .describe(\n        \"Enable both forms of flag input, e.g., `./script.js -f=value` and `-f value`.\",\n      ),\n    allowMultiple: z\n      .boolean()\n      .default(false)\n      .describe(\n        \"Allow passing the same flag multiple times, e.g., `-f val1 -f val2` results in an array.\",\n      ),\n    description: z\n      .union([z.string(), z.array(z.string())])\n      .describe(\"Textual description for help messages.\"),\n    options: z\n      .array(z.string().min(1))\n      .min(1, \"Flag must have at least one option (e.g., ['-f', '--flag'])\")\n      .describe(\"Array of option strings, e.g., ['-f', '--flag'].\"),\n    defaultValue: z\n      .any()\n      .optional()\n      .describe(\"Default value if the flag is not provided.\"),\n    type: z\n      .union([\n        z.any().refine((val) => val === String, { message: \"Must be String constructor\" }),\n        z.any().refine((val) => val === Number, { message: \"Must be Number constructor\" }),\n        z.any().refine((val) => val === Boolean, { message: \"Must be Boolean constructor\" }),\n        z.any().refine((val) => val === Array, { message: \"Must be Array constructor\" }),\n        z.any().refine((val) => val === Object, { message: \"Must be Object constructor\" }),\n        z.function().args(z.string()).returns(z.any()), // Custom parser function\n        z\n          .string()\n          .refine(\n            (value) =>\n              [\"boolean\", \"string\", \"number\", \"array\", \"object\"].includes(\n                value.toLowerCase(),\n              ),\n            { message: \"Invalid type string. Must be one of 'boolean', 'string', 'number', 'array', 'object'.\" },\n          ),\n      ])\n      .default(\"string\")\n      .describe(\"Expected data type or a custom parser function. Defaults to 'string'.\"),\n    mandatory: z\n      .union([z.boolean(), z.function().args(z.any()).returns(z.boolean())]) // `z.any()` for parsedArgs flexibility\n      .optional()\n      .describe(\"Makes the flag mandatory, can be a boolean or a function conditional on other args.\"),\n    flagOnly: z\n      .boolean()\n      .default(false)\n      .describe(\n        \"If true, the flag's presence is noted (true/false), and any subsequent value is not consumed by this flag.\",\n      ),\n    validate: z // User-provided validation function\n      .function()\n      .args(z.any().optional(), z.any().optional()) // value, parsedArgs?\n      .returns(z.union([z.boolean(), z.string(), z.void(), z.promise(z.union([z.boolean(), z.string(), z.void()]))]))\n      .optional()\n      .describe(\"Custom validation function for the flag's value (receives value, parsedArgs).\"),\n    enum: z // User-provided enum values\n      .array(z.any())\n      .optional()\n      .describe(\"Array of allowed values for the flag.\"),\n  })\n  .passthrough() // Allow unrecognized properties, they won't be validated or processed beyond alias handling.\n  .transform((obj) => {\n    const newObj: { [key: string]: any } = { ...obj };\n\n    if (\"default\" in newObj && newObj[\"default\"] !== undefined && !(\"defaultValue\" in newObj)) {\n      newObj[\"defaultValue\"] = newObj[\"default\"];\n    }\n\n    if (\"required\" in newObj && newObj[\"required\"] !== undefined && !(\"mandatory\" in newObj)) {\n      newObj[\"mandatory\"] = newObj[\"required\"] as boolean | ((parsedArgs: any) => boolean);\n    }\n\n    return newObj;\n  });\n\nexport type IFlagCore = z.input<typeof zodFlagSchema>;\n\nexport type IFlag = IFlagCore & {\n  /** @alias defaultValue */\n  default?: any;\n  /** @alias mandatory */\n  required?: boolean | ((parsedArgs: TParsedArgs<any>) => boolean); // `any` for now for TParsedArgs generic\n  // This handler seems to be for sub-commands, not specific to flag definition itself\n  // It was part of the original IFlag in ArgParser.ts.\n  // Consider moving to ISubCommand interface if it's only used there.\n  handler?: (ctx: HandlerContext) => void | Promise<void>;\n};\n\nexport type ProcessedFlagCore = z.output<typeof zodFlagSchema>;\n\nexport type ProcessedFlag = Omit<ProcessedFlagCore, \"type\" | \"validate\" | \"enum\" | \"mandatory\"> & {\n  type:\n    | StringConstructor\n    | NumberConstructor\n    | BooleanConstructor\n    | ArrayConstructor\n    | ObjectConstructor\n    | ((value: string) => any);\n  validate?: (\n    value: any,\n    parsedArgs?: TParsedArgs<ProcessedFlag[]>,\n  ) => boolean | string | void | Promise<boolean | string | void>;\n  enum?: any[];\n  mandatory?: boolean | ((parsedArgs: TParsedArgs<ProcessedFlag[]>) => boolean);\n};\n\nexport type ResolveType<T> = T extends (...args: any[]) => infer R\n  ? R // Function\n  : T extends new (...args: any[]) => infer S\n  ? S // Constructor\n  : T extends 'string' ? string\n  : T extends 'number' ? number\n  : T extends 'boolean' ? boolean\n  : T extends 'array' ? any[]\n  : T extends 'object' ? Record<string, any>\n  : any; // Fallback\n\nexport type ExtractFlagType<Flag extends ProcessedFlag> =\n  Flag[\"flagOnly\"] extends true\n    ? Flag[\"allowMultiple\"] extends true\n      ? boolean[] // Array of booleans if flagOnly and allowMultiple\n      : boolean   // Single boolean if flagOnly\n    : Flag[\"allowMultiple\"] extends true\n      ? Array<ResolveType<Flag[\"type\"]>> // Array of resolved type\n      : ResolveType<Flag[\"type\"]>;       // Single resolved type\n\nexport type TParsedArgs<Flags extends readonly (IFlag | ProcessedFlag)[]> = { // Made generic to support both IFlag and ProcessedFlag arrays\n  [K in Flags[number][\"name\"]]: Flags[number] extends ProcessedFlag // Type assertion to help compiler\n    ? ExtractFlagType<Extract<Flags[number], { name: K } & ProcessedFlag>>\n    : any; // Fallback for IFlag, though ideally, TParsedArgs uses ProcessedFlag\n};\n\n\nexport type HandlerContext = {\n  args: TParsedArgs<ProcessedFlag[]>;\n  parentArgs?: TParsedArgs<ProcessedFlag[]>;\n  commandChain: string[];\n  parser: ArgParserInstance; // Using the forward declared 'any' type\n};\n\n// Forward-declare ArgParser for ISubCommand to use\n// We use 'any' here as ArgParser itself imports types from this file,\n// creating a potential circular dependency for type-checking at this specific point.\n// The actual ArgParser<SubCmdFlags> type will be used in ArgParser.ts.\ntype ArgParserForSubcommand = any;\n\nexport interface ISubCommand {\n  name: string;\n  description?: string;\n  parser: ArgParserForSubcommand;\n  handler?: (ctx: HandlerContext) => void | Promise<void>;\n}\n\n// Generic type for the collection of flags an ArgParser instance will manage.\n// Using ProcessedFlag as these are the flags after initial validation and transformation.\nexport type FlagsArray = readonly ProcessedFlag[];","import { IFlag, ProcessedFlag, zodFlagSchema } from \"./types\";\n\nexport class FlagManager {\n  #_flags: Map<string, ProcessedFlag> = new Map();\n  #throwForDuplicateFlags: boolean;\n\n  constructor(\n    options: { throwForDuplicateFlags?: boolean } = {},\n    initialFlags: readonly IFlag[] = [],\n  ) {\n    this.#throwForDuplicateFlags = options.throwForDuplicateFlags ?? false;\n    this.addFlags(initialFlags);\n  }\n\n  static _safeFlag(flag: IFlag): ProcessedFlag {\n    const parsedFromZod = zodFlagSchema.parse(flag);\n\n    let resolvedType: ProcessedFlag[\"type\"];\n    const inputTypeFromZod = parsedFromZod[\"type\"];\n\n    if (typeof inputTypeFromZod === \"string\") {\n      switch (inputTypeFromZod.toLowerCase()) {\n        case \"boolean\":\n          resolvedType = Boolean;\n          break;\n        case \"string\":\n          resolvedType = String;\n          break;\n        case \"number\":\n          resolvedType = Number;\n          break;\n        case \"array\":\n          resolvedType = Array;\n          break;\n        case \"object\":\n          resolvedType = Object;\n          break;\n        default:\n          throw new Error(`Invalid type string: ${inputTypeFromZod}`);\n      }\n    } else {\n      resolvedType = inputTypeFromZod as ProcessedFlag[\"type\"];\n    }\n\n    return {\n      ...parsedFromZod,\n      options: parsedFromZod[\"options\"],\n      type: resolvedType,\n      validate: parsedFromZod[\"validate\"],\n      enum: parsedFromZod[\"enum\"],\n      mandatory: parsedFromZod[\"mandatory\"],\n    };\n  }\n\n  addFlag(flag: IFlag): this {\n    const safeFlag = FlagManager._safeFlag(flag);\n\n    if (this.#_flags.has(safeFlag[\"name\"])) {\n      if (this.#throwForDuplicateFlags) {\n        throw new Error(\n          `FlagManager: Flag '${safeFlag[\"name\"]}' already exists.`,\n        );\n      } else {\n        console.warn(\n          `Warning: FlagManager: Flag '${safeFlag[\"name\"]}' already exists. Duplicate not added.`,\n        );\n        return this;\n      }\n    }\n\n    this.#_flags.set(safeFlag[\"name\"], safeFlag);\n    return this;\n  }\n\n  _setProcessedFlagForInheritance(processedFlag: ProcessedFlag): this {\n    if (this.#_flags.has(processedFlag[\"name\"])) {\n      return this;\n    }\n    this.#_flags.set(processedFlag[\"name\"], processedFlag);\n    return this;\n  }\n\n  addFlags(flags: readonly IFlag[]): this {\n    for (const flag of flags) {\n      this.addFlag(flag);\n    }\n    return this;\n  }\n\n  hasFlag(name: string): boolean {\n    return this.#_flags.has(name);\n  }\n\n  getFlag(name: string): ProcessedFlag | undefined {\n    return this.#_flags.get(name);\n  }\n\n  get flags(): ProcessedFlag[] {\n    return Array.from(this.#_flags.values());\n  }\n\n  get flagNames(): string[] {\n    return Array.from(this.#_flags.values()).map((flag) => flag[\"name\"]);\n  }\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport chalk from \"chalk\";\nimport { anyOf, char, createRegExp, oneOrMore } from \"magic-regexp\";\nimport { FlagManager } from \"./FlagManager\";\nimport {\n  HandlerContext,\n  IFlag,\n  ISubCommand,\n  ProcessedFlag,\n  TParsedArgs,\n} from \"./types\";\n\nexport class ArgParserError extends Error {\n  public commandChain: string[];\n  constructor(\n    message: string,\n    public cmdChain: string[] = [],\n  ) {\n    super(message);\n    this.name = \"ArgParserError\";\n    this.commandChain = cmdChain;\n  }\n}\n\n// zodFlagSchema, IFlag (zod-derived), ResolveType, ExtractFlagType, TParsedArgs (original)\n// have been moved to types.ts or are superseded by types from types.ts\n\ninterface IArgParserParams {\n  /**\n   * Add an extra new line between each flag group,\n   * makes the text more readable but uses more space\n   *\n   * Default: true\n   */\n  extraNewLine?: boolean;\n  /**\n   * Wraps the line at width, if shorter, wrapping will be more\n   * aggressive. Wrapping is based on words.\n   *\n   * Default: 50\n   * Minimum: 30\n   */\n  wrapAtWidth?: number;\n  /**\n   * Controls the placing of right text on the screen.\n   * The higher the value, the more to the right the text will be.\n   *\n   * Default: 30\n   * Minimum: 20\n   */\n  blankSpaceWidth?: number;\n  /**\n   * Character to display next to the flag to express mandatory fields.\n   *\n   * Default: *\n   */\n  mandatoryCharacter?: string;\n  /**\n   * Throw an error if a flag is added more than once\n   * @default false\n   */\n  throwForDuplicateFlags?: boolean;\n  description?: string; // New property for the description\n  /**\n   * Automatically handle ArgParserErrors by printing a formatted message\n   * and exiting. Set to false to catch ArgParserError manually.\n   * @default true\n   */\n  handleErrors?: boolean;\n  /**\n   * The command name to display in help suggestions (e.g., 'dabl').\n   * If not provided, it falls back to appName or guessing from the script path.\n   * @since 1.5.1\n   */\n  appCommandName?: string;\n  /**\n   * If true, when this parser is added as a sub-command, it will inherit\n   * flags from its direct parent *unless* a flag with the same name\n   * already exists in this parser. Child flags take precedence.\n   * @default false\n   */\n  inheritParentFlags?: boolean;\n}\n\ninterface IParseOptions {\n  /**\n   * When true, skips help flag processing (doesn't exit or show help)\n   * @default false\n   */\n  skipHelpHandling?: boolean;\n  /**\n   * When true, skips the execution of any command handlers.\n   * @default false\n   */\n  skipHandlers?: boolean;\n}\n\ntype TParsedArgsWithRouting<T = any> = T & {\n  $commandChain?: string[];\n  handlerToExecute?: { handler: Function; context: HandlerContext };\n};\n\ntype RecursiveParseResult = {\n  finalArgs: TParsedArgsWithRouting<any>;\n  handlerToExecute?: { handler: Function; context: HandlerContext };\n};\n\nexport class ArgParser {\n  #appName: string = \"Argument Parser\";\n  #appCommandName?: string;\n  #subCommandName: string = \"\";\n  #parameters: IArgParserParams = {\n    extraNewLine: true,\n    wrapAtWidth: 50,\n    blankSpaceWidth: 30,\n    mandatoryCharacter: \"*\",\n  };\n  #handler?: (ctx: HandlerContext) => void;\n  #throwForDuplicateFlags: boolean = false;\n  #description?: string;\n  #handleErrors: boolean = true;\n  #parentParser?: ArgParser;\n  #lastParseResult: TParsedArgs<ProcessedFlag[]> = {};\n  #inheritParentFlags: boolean = false;\n  #subCommands: Map<string, ISubCommand> = new Map();\n  #flagManager: FlagManager;\n\n  constructor(\n    options: IArgParserParams & {\n      appName?: string;\n      subCommands?: ISubCommand[];\n      handler?: (ctx: HandlerContext) => void;\n    } = {},\n    initialFlags?: readonly IFlag[],\n  ) {\n    this.#appName = options.appName || \"app\";\n    if (\n      options.blankSpaceWidth &&\n      !isNaN(Number(options.blankSpaceWidth)) &&\n      Number(options.blankSpaceWidth) > 20\n    )\n      this.#parameters.blankSpaceWidth = Number(options.blankSpaceWidth);\n\n    if (\n      options.wrapAtWidth &&\n      !isNaN(Number(options.wrapAtWidth)) &&\n      Number(options.wrapAtWidth) > 30\n    )\n      this.#parameters.wrapAtWidth = Number(options.wrapAtWidth);\n\n    if (typeof options.extraNewLine === \"boolean\")\n      this.#parameters.extraNewLine = Boolean(options.extraNewLine);\n\n    if (typeof options.mandatoryCharacter === \"string\")\n      this.#parameters.mandatoryCharacter = options.mandatoryCharacter;\n\n    if (typeof options.throwForDuplicateFlags === \"boolean\")\n      this.#throwForDuplicateFlags = options.throwForDuplicateFlags;\n\n    this.#flagManager = new FlagManager(\n      {\n        throwForDuplicateFlags: this.#throwForDuplicateFlags,\n      },\n      initialFlags || [],\n    );\n\n    this.#handleErrors = options.handleErrors ?? true;\n    this.#inheritParentFlags = options.inheritParentFlags ?? false;\n    this.#description = options.description;\n    this.#handler = options.handler;\n    this.#appCommandName = options.appCommandName;\n\n    const helpFlag: IFlag = {\n      name: \"help\",\n      description: \"Display this help message and exits\",\n      mandatory: false,\n      type: Boolean,\n      options: [\"-h\", \"--help\"],\n      defaultValue: undefined,\n      allowLigature: false,\n      allowMultiple: false,\n      flagOnly: true,\n      enum: [],\n      validate: (_value?: any, _parsedArgs?: any) => true, // Ensure signature matches Zod schema for .args()\n    };\n    this.#flagManager.addFlag(helpFlag); // Add the help flag via FlagManager\n\n    if (options.subCommands) {\n      for (const sub of options.subCommands) {\n        this.addSubCommand(sub);\n      }\n    }\n  }\n\n  get flags(): ProcessedFlag[] {\n    return this.#flagManager.flags;\n  }\n\n  get flagNames(): string[] {\n    return this.#flagManager.flagNames; // Delegates to FlagManager\n  }\n\n  private _addToOutput(\n    flag: ProcessedFlag, // Changed from Flags[number]\n    arg: any,\n    output: TParsedArgs<ProcessedFlag[]>,\n    _parseOptions?: IParseOptions,\n  ) {\n    let value: unknown = arg;\n\n    if (flag.type === Boolean) {\n      if (typeof arg === \"boolean\") {\n        value = arg;\n      } else if (typeof arg === \"string\") {\n        value = /(true|yes|1)/i.test(arg);\n      } else {\n        value = new (flag[\"type\"] as ObjectConstructor)(value);\n      }\n    } else if (typeof flag[\"type\"] === \"function\") {\n      value = (flag[\"type\"] as Function)(value as string);\n    } else if (typeof flag[\"type\"] === \"object\") {\n      value = new (flag[\"type\"] as ObjectConstructor)(value);\n    }\n\n    if (flag[\"enum\"] && flag[\"enum\"].length > 0) {\n      const allowedValues = flag[\"enum\"]\n        .map((v: any) => (typeof v === \"string\" ? `'${v}'` : v))\n        .join(\", \");\n\n      if (!flag[\"enum\"].includes(value)) {\n        throw new ArgParserError(\n          `Invalid value '${value}' for flag '${chalk.yellow(flag[\"name\"])}'. ` +\n            `Allowed values: ${allowedValues}`,\n          this.getCommandChain(),\n        );\n      }\n    }\n\n    if (flag[\"validate\"]) {\n      const validationResult = flag[\"validate\"](value, output);\n      if (validationResult === false) {\n        throw new ArgParserError(\n          `Validation failed for flag '${chalk.yellow(flag[\"name\"])}' with value '${value}'`,\n          this.getCommandChain(),\n        );\n      } else if (typeof validationResult === \"string\") {\n        throw new ArgParserError(validationResult, this.getCommandChain());\n      }\n    }\n\n    if (flag[\"allowMultiple\"] && !Array.isArray(output[flag[\"name\"]])) {\n      output[flag[\"name\"]] = [] as any;\n    }\n\n    return flag[\"allowMultiple\"]\n      ? (output[flag[\"name\"]] as any[]).push(value)\n      : (output[flag[\"name\"]] = value as any);\n  }\n\n  addFlags(flags: readonly IFlag[]): this {\n    this.#flagManager.addFlags(flags);\n    return this;\n  }\n\n  addFlag(flag: IFlag): this {\n    this.#flagManager.addFlag(flag);\n    return this;\n  }\n\n  addSubCommand(subCommandConfig: ISubCommand): this {\n    if (this.#subCommands.has(subCommandConfig.name)) {\n      throw new Error(`Sub-command '${subCommandConfig.name}' already exists`);\n    }\n\n    const subParser = subCommandConfig.parser;\n\n    if (!(subParser instanceof ArgParser)) {\n      throw new Error(\n        `Parser for subcommand '${subCommandConfig.name}' is not an instance of ArgParser. ` +\n          `Please provide 'new ArgParser(...)' for the 'parser' property of an ISubCommand.`,\n      );\n    }\n\n    subParser.#parentParser = this;\n    subParser.#subCommandName = subCommandConfig.name;\n    if (!subParser.#appCommandName && this.#appCommandName) {\n      subParser.#appCommandName = this.#appCommandName;\n    }\n\n    if (subParser.#inheritParentFlags) {\n      const parentFlags = this.#flagManager.flags;\n      for (const parentFlag of parentFlags) {\n        if (!subParser.#flagManager.hasFlag(parentFlag[\"name\"])) {\n          subParser.#flagManager._setProcessedFlagForInheritance(parentFlag);\n        }\n      }\n    }\n\n    this.#subCommands.set(subCommandConfig.name, subCommandConfig);\n\n    if (subCommandConfig.handler) {\n      subParser.setHandler(subCommandConfig.handler);\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the handler function for this specific parser instance.\n   * This handler will be executed if this parser is the final one\n   * in the command chain and `executeHandlers` is enabled on the root parser.\n   *\n   * @param handler - The function to execute.\n   * @returns The ArgParser instance for chaining.\n   */\n  setHandler(handler: (ctx: HandlerContext) => void): this {\n    this.#handler = handler;\n    return this;\n  }\n\n  printAll(filePath?: string): void {\n    if (filePath) {\n      try {\n        const dir = path.dirname(filePath);\n        if (!fs.existsSync(dir)) {\n          fs.mkdirSync(dir, { recursive: true });\n        }\n\n        if (filePath.toLowerCase().endsWith(\".json\")) {\n          const outputObject = this.#_buildRecursiveJson(this);\n          const jsonString = JSON.stringify(outputObject, null, 2);\n          fs.writeFileSync(filePath, jsonString);\n          console.log(`ArgParser configuration JSON dumped to: ${filePath}`);\n        } else {\n          const outputString = this.#_buildRecursiveString(this, 0);\n          const plainText = outputString.replace(\n            /[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,\n            \"\",\n          );\n          fs.writeFileSync(filePath, plainText);\n          console.log(`ArgParser configuration text dumped to: ${filePath}`);\n        }\n      } catch (error) {\n        console.error(\n          `Error writing ArgParser configuration to file '${filePath}':`,\n          error,\n        );\n      }\n    } else {\n      console.log(\"\\n--- ArgParser Configuration Dump ---\");\n      this.#_printRecursiveToConsole(this, 0);\n      console.log(\"--- End Configuration Dump ---\\\\n\");\n    }\n  }\n\n  #_identifyCommandChainAndParsers(\n    argsToParse: string[],\n    currentParser: ArgParser,\n    commandChainSoFar: string[],\n    parserChainSoFar: ArgParser[],\n  ): {\n    finalParser: ArgParser;\n    commandChain: string[];\n    parserChain: ArgParser[];\n    remainingArgs: string[];\n  } {\n    let subCommandIndex = -1;\n    let subCommandName: string | null = null;\n\n    for (let i = 0; i < argsToParse.length; i++) {\n      const potentialSubCommand = argsToParse[i];\n      if (currentParser.#subCommands.has(potentialSubCommand)) {\n        subCommandIndex = i;\n        subCommandName = potentialSubCommand;\n        break;\n      }\n    }\n\n    if (subCommandIndex === -1 || subCommandName === null) {\n      return {\n        finalParser: currentParser,\n        commandChain: commandChainSoFar,\n        parserChain: parserChainSoFar,\n        remainingArgs: argsToParse,\n      };\n    }\n\n    const subCommandConfig = currentParser.#subCommands.get(subCommandName);\n    if (!subCommandConfig || !(subCommandConfig.parser instanceof ArgParser)) {\n      throw new Error(\n        `Internal error: Subcommand '${subCommandName!}' configuration is invalid or parser is missing.`,\n      );\n    }\n    const nextParser = subCommandConfig.parser;\n    const nextArgs = argsToParse.slice(subCommandIndex + 1);\n    const nextCommandChain = [...commandChainSoFar, subCommandName];\n    const nextParserChain = [...parserChainSoFar, nextParser];\n\n    return this.#_identifyCommandChainAndParsers(\n      nextArgs,\n      nextParser,\n      nextCommandChain,\n      nextParserChain,\n    );\n  }\n\n  #_handleGlobalChecks(\n    processArgs: string[],\n    options?: IParseOptions,\n  ): boolean {\n    if (processArgs.length === 0 && !this.#parentParser && !this.#handler) {\n      console.log(this.helpText());\n      if (typeof process === \"object\" && typeof process.exit === \"function\") {\n        process.exit(0 as never);\n      }\n      return true;\n    }\n\n    if (processArgs.includes(\"--LIB-debug-print\")) {\n      this.printAll(\"ArgParser.full.json\");\n      if (typeof process === \"object\" && typeof process.exit === \"function\") {\n        process.exit(0);\n      }\n      return true;\n    }\n\n    const { finalParser: identifiedFinalParser } =\n      this.#_identifyCommandChainAndParsers(processArgs, this, [], [this]);\n\n    if (processArgs.includes(\"--LIB-debug\")) {\n      console.log(\n        chalk.yellow.bold(\"\\n--- ArgParser --LIB-debug Runtime Context ---\"),\n      );\n\n      const {\n        commandChain: identifiedCommandChain,\n        parserChain: _identifiedParserChain,\n      } = this.#_identifyCommandChainAndParsers(processArgs, this, [], [this]);\n\n      console.log(\n        `Identified Command Chain: ${chalk.cyan(identifiedCommandChain.join(\" -> \") || \"(root)\")}`,\n      );\n      console.log(\n        `Identified Final Parser: ${chalk.cyan(identifiedFinalParser.#subCommandName || identifiedFinalParser.#appName)}`,\n      );\n\n      let currentParser: ArgParser = this;\n      let remainingArgs = [...processArgs];\n      let accumulatedArgs: TParsedArgs<any> = {};\n      const parsingSteps: {\n        level: string;\n        argsSlice: string[];\n        parsed?: TParsedArgs<any>;\n        error?: string;\n      }[] = [];\n\n      const rootSubCommandIndex = remainingArgs.findIndex((arg) =>\n        currentParser.#subCommands.has(arg),\n      );\n      const rootArgsSlice =\n        rootSubCommandIndex === -1\n          ? remainingArgs\n          : remainingArgs.slice(0, rootSubCommandIndex);\n      parsingSteps.push({ level: \"(root)\", argsSlice: rootArgsSlice });\n      try {\n        const { parsedArgs: rootParsedArgs } = currentParser.#parseFlags(\n          rootArgsSlice,\n          { skipHelpHandling: true },\n        );\n        parsingSteps[0].parsed = rootParsedArgs;\n        accumulatedArgs = { ...accumulatedArgs, ...rootParsedArgs };\n      } catch (e: any) {\n        parsingSteps[0].error = e.message;\n      }\n      remainingArgs =\n        rootSubCommandIndex === -1\n          ? []\n          : remainingArgs.slice(rootSubCommandIndex);\n\n      for (let i = 0; i < identifiedCommandChain.length; i++) {\n        const subCommandName = identifiedCommandChain[i];\n        if (!currentParser.#subCommands.has(subCommandName)) {\n          parsingSteps.push({\n            level: `Error`,\n            argsSlice: [],\n            error: `Could not find sub-command parser for '${subCommandName}'`,\n          });\n          break;\n        }\n        currentParser = currentParser.#subCommands.get(subCommandName)?.parser;\n        remainingArgs = remainingArgs.slice(1);\n\n        const nextSubCommandIndex = remainingArgs.findIndex((arg) =>\n          currentParser.#subCommands.has(arg),\n        );\n        const currentLevelArgsSlice =\n          nextSubCommandIndex === -1\n            ? remainingArgs\n            : remainingArgs.slice(0, nextSubCommandIndex);\n        const stepInfo: {\n          level: string;\n          argsSlice: string[];\n          parsed?: TParsedArgs<any>;\n          error?: string;\n        } = {\n          level: subCommandName,\n          argsSlice: currentLevelArgsSlice,\n        };\n        parsingSteps.push(stepInfo);\n\n        try {\n          const { parsedArgs: currentLevelParsedArgs } =\n            currentParser.#parseFlags(currentLevelArgsSlice, {\n              skipHelpHandling: true,\n            });\n          stepInfo.parsed = currentLevelParsedArgs;\n          accumulatedArgs = { ...accumulatedArgs, ...currentLevelParsedArgs };\n        } catch (e: any) {\n          stepInfo.error = e.message;\n        }\n        remainingArgs =\n          nextSubCommandIndex === -1\n            ? []\n            : remainingArgs.slice(nextSubCommandIndex);\n      }\n\n      console.log(chalk.yellow(\"\\nParsing Simulation Steps:\"));\n      parsingSteps.forEach((step) => {\n        console.log(`  Level: ${chalk.cyan(step.level)}`);\n        console.log(\n          `    Args Slice Considered: ${JSON.stringify(step.argsSlice)}`,\n        );\n        if (step.parsed) {\n          console.log(\n            `    Parsed Args at this Level: ${JSON.stringify(step.parsed)}`,\n          );\n        }\n        if (step.error) {\n          console.log(\n            `    ${chalk.red(\"Error during parse simulation:\")} ${step.error}`,\n          );\n        }\n      });\n\n      console.log(\n        chalk.yellow(\n          \"\\nFinal Accumulated Args State (before final validation):\",\n        ),\n      );\n      console.log(JSON.stringify(accumulatedArgs, null, 2));\n\n      console.log(chalk.yellow(\"\\nArguments Remaining After Simulation:\"));\n      console.log(JSON.stringify(remainingArgs, null, 2));\n\n      console.log(\n        chalk.yellow.bold(\n          \"\\n--- ArgParser Static Configuration (Final Parser) ---\",\n        ),\n      );\n      identifiedFinalParser.printAll();\n\n      console.log(chalk.yellow.bold(\"--- End ArgParser --LIB-debug ---\"));\n      if (typeof process === \"object\" && typeof process.exit === \"function\") {\n        process.exit(0);\n      }\n      return true;\n    }\n\n    // ---- BEGIN ADDED DIAGNOSTIC LOG FOR identifiedFinalParser ----\n    let parserNameForLog = \"undefined_parser\";\n    if (identifiedFinalParser instanceof ArgParser) {\n      // Access private fields only if it's a confirmed ArgParser instance\n      parserNameForLog =\n        (identifiedFinalParser as any)[\"#subCommandName\"] ||\n        (identifiedFinalParser as any)[\"#appName\"];\n    } else if (identifiedFinalParser) {\n      parserNameForLog =\n        (identifiedFinalParser as any).name ||\n        (identifiedFinalParser as any).appName ||\n        \"unknown_type\";\n    }\n    // console.log(\n    //   `[ArgParser #_handleGlobalChecks Debug] identifiedFinalParser: constructor=${identifiedFinalParser ? 'defined' : 'undefined'}, isArgParser=${identifiedFinalParser instanceof ArgParser}, name=${parserNameForLog}`\n    // );\n    // ---- END ADDED DIAGNOSTIC LOG FOR identifiedFinalParser ----\n\n    // ---- BEGIN GUARD FOR identifiedFinalParser ----\n    if (!(identifiedFinalParser instanceof ArgParser)) {\n      console.error(\n        `[ArgParser #_handleGlobalChecks Critical Error] identifiedFinalParser is not an instance of ArgParser. Cannot process help. Name: ${parserNameForLog}, Constructor: ${identifiedFinalParser ? (identifiedFinalParser as any).constructor?.name : \"undefined\"}`,\n      );\n      // Returning false to prevent further processing with an invalid parser,\n      // which could lead to more cryptic errors or incorrect behavior.\n      return false;\n    }\n    // ---- END GUARD FOR identifiedFinalParser ----\n\n    const helpFlagDefinition =\n      identifiedFinalParser.#flagManager.getFlag(\"help\");\n    if (helpFlagDefinition && !options?.skipHelpHandling) {\n      const helpOptions = helpFlagDefinition[\"options\"];\n\n      // ---- BEGIN ADDED DEBUG AND DEFENSIVE CHECK ----\n      // if (!Array.isArray(helpOptions) || helpOptions.length === 0) {\n      //   console.warn(\n      //     `[ArgParser Debug] helpOptions is not a valid array or is empty. Value: ${JSON.stringify(helpOptions)}, Type: ${typeof helpOptions}`,\n      //     `Parser: ${parserNameForLog}`, // Use the determined parserNameForLog\n      //   );\n      //   // Potentially, we might even want to return false here or throw,\n      //   // as help cannot be processed correctly. For now, just log and continue.\n      // } else {\n      //   // Optional: Log the valid helpOptions for debugging successful cases\n      //   // console.log(`[ArgParser Debug] Valid helpOptions: ${JSON.stringify(helpOptions)} for parser ${parserNameForLog}`);\n      // }\n      // ---- END ADDED DEBUG AND DEFENSIVE CHECK ----\n\n      const helpRequested = processArgs.some((arg) =>\n        helpOptions.includes(arg),\n      );\n\n      if (helpRequested) {\n        console.log(identifiedFinalParser.helpText());\n        if (typeof process === \"object\" && typeof process.exit === \"function\") {\n          process.exit(0 as never);\n        }\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  #_validateMandatoryFlags(\n    finalArgs: TParsedArgsWithRouting<any>,\n    parserChain: ArgParser[],\n    commandChain: string[],\n  ): void {\n    const finalMandatoryFlagsMissing: {\n      name: string;\n      parserName: string;\n      commandChain: string[];\n    }[] = [];\n    const checkedFlagNames = new Set<string>();\n\n    for (const parser of parserChain) {\n      const currentCommandChain = parser.getCommandChain();\n      for (const flag of parser.#flagManager.flags) {\n        // Use FlagManager\n        if (flag[\"name\"] === \"help\" || checkedFlagNames.has(flag[\"name\"]))\n          continue;\n\n        const isMandatory =\n          typeof flag[\"mandatory\"] === \"function\"\n            ? flag[\"mandatory\"](finalArgs)\n            : flag[\"mandatory\"];\n\n        if (!isMandatory) continue;\n\n        const value = finalArgs[flag[\"name\"] as keyof typeof finalArgs];\n        let currentFlagIsMissing = false;\n\n        if (flag[\"allowMultiple\"]) {\n          // For allowMultiple, it's missing if undefined OR an empty array\n          if (\n            value === undefined ||\n            (Array.isArray(value) && value.length === 0)\n          ) {\n            currentFlagIsMissing = true;\n          }\n        } else {\n          // For non-allowMultiple, it's missing if undefined\n          if (value === undefined) {\n            currentFlagIsMissing = true;\n          }\n        }\n\n        if (currentFlagIsMissing) {\n          if (!checkedFlagNames.has(flag[\"name\"])) {\n            finalMandatoryFlagsMissing.push({\n              name: flag[\"name\"],\n              parserName: parser.#subCommandName || parser.#appName,\n              commandChain: currentCommandChain,\n            });\n            checkedFlagNames.add(flag[\"name\"]);\n          }\n        }\n      }\n    }\n\n    if (finalMandatoryFlagsMissing.length > 0) {\n      throw new ArgParserError(\n        `Missing mandatory flags: ${finalMandatoryFlagsMissing\n          .map((flag) => chalk.yellow(flag[\"name\"]))\n          .join(\", \")}`,\n        commandChain,\n      );\n    }\n  }\n\n  #_applyDefaultValues(\n    finalArgs: TParsedArgsWithRouting<any>,\n    finalParser: ArgParser,\n  ): void {\n    for (const flag of finalParser.#flagManager.flags) {\n      // Use FlagManager\n      const flagName = flag[\"name\"] as string;\n      if (\n        finalArgs[flagName] === undefined &&\n        flag[\"defaultValue\"] !== undefined\n      ) {\n        if (flag[\"allowMultiple\"]) {\n          finalArgs[flagName] = Array.isArray(flag[\"defaultValue\"])\n            ? flag[\"defaultValue\"]\n            : [flag[\"defaultValue\"]];\n        } else {\n          finalArgs[flagName] = flag[\"defaultValue\"];\n        }\n      }\n    }\n  }\n\n  #_prepareAndExecuteHandler(\n    handlerToExecute: RecursiveParseResult[\"handlerToExecute\"],\n    finalArgs: TParsedArgsWithRouting<any>,\n    skipHandlers: boolean,\n  ): void {\n    if (skipHandlers || !handlerToExecute) {\n      return;\n    }\n\n    const finalParserWhoseHandlerWillRun = handlerToExecute.context.parser;\n    const finalParserFlags = finalParserWhoseHandlerWillRun.#flagManager.flags;\n    const handlerArgs = handlerToExecute.context.args;\n\n    for (const flag of finalParserFlags) {\n      const flagName = flag[\"name\"] as keyof typeof finalArgs;\n      if (finalArgs.hasOwnProperty(flagName)) {\n        (handlerArgs as any)[flagName] = (finalArgs as any)[flagName];\n      } else if (\n        flag[\"allowMultiple\"] &&\n        !handlerArgs.hasOwnProperty(flagName)\n      ) {\n        (handlerArgs as any)[flagName] = [];\n      }\n    }\n    handlerToExecute.context.args = handlerArgs;\n\n    handlerToExecute.handler(handlerToExecute.context);\n  }\n\n  parse(\n    processArgs: string[],\n    options?: IParseOptions,\n  ): TParsedArgsWithRouting<any> {\n    if (this.#_handleGlobalChecks(processArgs, options)) {\n      return {} as TParsedArgsWithRouting<any>;\n    }\n\n    try {\n      const {\n        finalParser: identifiedFinalParser,\n        commandChain: identifiedCommandChain,\n        parserChain: identifiedParserChain,\n      } = this.#_identifyCommandChainAndParsers(processArgs, this, [], [this]);\n\n      const { finalArgs, handlerToExecute } = this._parseRecursive(\n        processArgs,\n        this,\n        {},\n        [],\n        options,\n      );\n\n      // Set command chain in final args\n      if (identifiedCommandChain.length > 0) {\n        (finalArgs as any).$commandChain = identifiedCommandChain;\n      }\n\n      this.#_validateMandatoryFlags(\n        finalArgs,\n        identifiedParserChain,\n        identifiedCommandChain,\n      );\n\n      this.#_applyDefaultValues(finalArgs, identifiedFinalParser);\n\n      this.#_prepareAndExecuteHandler(\n        handlerToExecute,\n        finalArgs,\n        options?.skipHandlers ?? false,\n      );\n\n      return finalArgs;\n    } catch (error) {\n      if (error instanceof ArgParserError) {\n        if (this.#handleErrors) {\n          this.#displayErrorAndExit(error);\n          return {} as TParsedArgsWithRouting<any>;\n        } else {\n          throw error;\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Recursive helper for parsing arguments and handling sub-commands.\n   * This method assumes the global help check has already been performed in `parse`.\n   */\n  private _parseRecursive(\n    argsToParse: string[],\n    currentParser: ArgParser,\n    accumulatedParentArgs: TParsedArgs<any>,\n    commandChainSoFar: string[],\n    options?: IParseOptions,\n  ): RecursiveParseResult {\n    let subCommandIndex = -1;\n    let subCommandName: string | null = null;\n\n    // Find the index of the first argument that matches a defined sub-command name\n    for (let i = 0; i < argsToParse.length; i++) {\n      const potentialSubCommand = argsToParse[i];\n      if (currentParser.#subCommands.has(potentialSubCommand)) {\n        subCommandIndex = i;\n        subCommandName = potentialSubCommand;\n        break;\n      }\n    }\n\n    // Determine which arguments belong to the current parser level\n    const argsForCurrentLevel =\n      subCommandIndex === -1\n        ? argsToParse\n        : argsToParse.slice(0, subCommandIndex);\n\n    // Parse flags for the current level using #parseFlags\n    const { parsedArgs: currentLevelArgs, firstUnconsumedIndex } =\n      currentParser.#parseFlags(argsForCurrentLevel, options);\n\n    // Apply default values for the current parser's flags to its args\n    currentParser.#_applyDefaultValues(currentLevelArgs, currentParser);\n\n    const combinedArgsFromThisAndParents = {\n      ...accumulatedParentArgs,\n      ...currentLevelArgs,\n    };\n\n    if (subCommandIndex === -1 || subCommandName === null) {\n      if (firstUnconsumedIndex < argsForCurrentLevel.length) {\n        const unknownCommand = argsForCurrentLevel[firstUnconsumedIndex];\n        throw new ArgParserError(\n          `Unknown command: '${chalk.yellow(unknownCommand)}'`,\n          commandChainSoFar,\n        );\n      }\n\n      const finalParseResultArgs = { ...combinedArgsFromThisAndParents };\n      if (commandChainSoFar.length > 0) {\n        finalParseResultArgs[\"$commandChain\"] = commandChainSoFar;\n      }\n\n      let handlerToExecute: RecursiveParseResult[\"handlerToExecute\"] =\n        undefined;\n      if (currentParser.#handler) {\n        handlerToExecute = {\n          handler: currentParser.#handler,\n          context: {\n            args: currentLevelArgs,\n            parentArgs: accumulatedParentArgs,\n            commandChain: commandChainSoFar,\n            parser: currentParser,\n          },\n        };\n      }\n      return { finalArgs: finalParseResultArgs, handlerToExecute };\n    }\n    if (firstUnconsumedIndex < argsForCurrentLevel.length) {\n      const unknownCommand = argsForCurrentLevel[firstUnconsumedIndex];\n      throw new ArgParserError(\n        `Unknown command: '${chalk.yellow(unknownCommand)}'`,\n        commandChainSoFar,\n      );\n    }\n\n    const subCommandConfig = currentParser.#subCommands.get(subCommandName!);\n    if (!subCommandConfig || !(subCommandConfig.parser instanceof ArgParser)) {\n      // This should ideally not be reached if addSubCommand validated the parser instance\n      throw new ArgParserError(\n        `Internal error: Subcommand '${subCommandName!}' is misconfigured or its parser is not a valid ArgParser instance.`,\n        commandChainSoFar,\n      );\n    }\n    const nextParser = subCommandConfig.parser;\n    const nextArgs = argsToParse.slice(subCommandIndex + 1);\n    const nextCommandChain = [...commandChainSoFar, subCommandName];\n    const combinedArgsForNextLevel = {\n      ...accumulatedParentArgs,\n      ...currentLevelArgs,\n    };\n\n    return this._parseRecursive(\n      nextArgs,\n      nextParser,\n      combinedArgsForNextLevel,\n      nextCommandChain,\n      options,\n    );\n  }\n\n  #parseFlags(\n    args: string[],\n    options?: IParseOptions,\n  ): {\n    parsedArgs: TParsedArgs<ProcessedFlag[]>;\n    firstUnconsumedIndex: number;\n  } {\n    const flags = this.#flagManager.flags;\n\n    const output: TParsedArgs<ProcessedFlag[]> = Object.fromEntries(\n      flags.map((flag) => [\n        flag[\"name\"],\n        flag[\"allowMultiple\"] ? [] : undefined,\n      ]),\n    ) as TParsedArgs<ProcessedFlag[]>;\n\n    let consumedIndices = new Set<number>();\n\n    for (const flagToCheck of flags) {\n      if (flagToCheck[\"allowLigature\"] && !flagToCheck[\"flagOnly\"]) {\n        const regex = createRegExp(\n          anyOf(\n            ...flagToCheck[\"options\"].map((option: string) => `${option}=`),\n          ),\n          oneOrMore(char).groupedAs(\"arg\"),\n        );\n        for (let i = 0; i < args.length; i++) {\n          if (consumedIndices.has(i)) continue;\n          const itemToCheck = args[i];\n          const matches = regex.exec(`${itemToCheck}`);\n          if (matches?.groups?.[\"arg\"]) {\n            this._addToOutput(\n              flagToCheck,\n              matches?.groups?.[\"arg\"],\n              output,\n              options,\n            );\n            consumedIndices.add(i);\n            if (!flagToCheck[\"allowMultiple\"]) break;\n          }\n        }\n      }\n    }\n\n    for (const flagToCheck of flags) {\n      for (let index = 0; index < args.length; index++) {\n        if (consumedIndices.has(index)) continue;\n\n        const value = args[index];\n        const nextIndex = index + 1;\n        const nextValueExists = nextIndex < args.length;\n        const nextValue = nextValueExists ? args[nextIndex] : undefined;\n        const nextValueIsFlag =\n          typeof nextValue === \"string\" && nextValue.startsWith(\"-\");\n\n        if (flagToCheck[\"options\"].includes(value)) {\n          // Mark the flag itself as consumed immediately\n          consumedIndices.add(index);\n\n          if (flagToCheck[\"flagOnly\"]) {\n            this._addToOutput(flagToCheck, true, output, options);\n          } else if (nextValueExists && !nextValueIsFlag) {\n            this._addToOutput(flagToCheck, nextValue, output, options);\n            consumedIndices.add(nextIndex);\n          } else if (flagToCheck[\"type\"] === Boolean) {\n            this._addToOutput(flagToCheck, true, output, options);\n          }\n          if (!flagToCheck[\"allowMultiple\"]) break;\n        }\n      }\n    }\n\n    let firstUnconsumedIndex = args.length;\n    for (let i = 0; i < args.length; i++) {\n      if (!consumedIndices.has(i)) {\n        firstUnconsumedIndex = i;\n        break;\n      }\n    }\n\n    return { parsedArgs: output, firstUnconsumedIndex };\n  }\n\n  helpText(): string {\n    const cyan = chalk.cyan;\n    const green = chalk.green;\n    const white = chalk.white;\n    const red = chalk.red;\n    const dim = chalk.dim;\n\n    let rootAppName = this.#appName;\n    let current: ArgParser | undefined = this;\n    while (current.#parentParser) {\n      current = current.#parentParser;\n    }\n    if (current) {\n      rootAppName = current.#appName;\n    }\n\n    const helpTitle = this.#subCommandName\n      ? `${rootAppName} ${this.#subCommandName}`\n      : rootAppName;\n\n    let help = `${cyan(`${helpTitle} Help`)} (${this.#parameters.mandatoryCharacter} = Mandatory fields):\\n\\n`;\n\n    // ---- BEGIN ADDED DIAGNOSTIC LOG ----\n    // console.log(\n    //   `[ArgParser helpText Debug] 'this' context: constructor.name = ${this?.constructor?.name}, is ArgParser instance = ${this instanceof ArgParser}, subCommandName = ${this.#subCommandName || '(root)'}`,\n    // );\n    // ---- END ADDED DIAGNOSTIC LOG ----\n\n    if (this.#description) {\n      help += `${white(this.#description)}\\n\\n`;\n    }\n\n    const indent = (level: number = 1) => \"  \".repeat(level);\n\n    if (this.#subCommands.size > 0) {\n      // Use Map.size\n      help += `${cyan(\"Available sub-commands:\")}\\n`;\n      // Iterate over Map entries, then sort\n      help += Array.from(this.#subCommands.entries())\n        .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))\n        .map(([name, subCommandConfig]) => {\n          // subCommandConfig is an ISubCommand object from the map\n          const actualSubParserInstance = subCommandConfig.parser;\n\n          // Guard against misconfiguration, though addSubCommand should prevent non-ArgParser instances\n          if (!(actualSubParserInstance instanceof ArgParser)) {\n            return `${indent()}${green(name.padEnd(20))} [Error: Subcommand '${name}' has an invalid parser configuration]`;\n          }\n\n          let subHelp = `${indent()}${green(name.padEnd(20))} ${white(actualSubParserInstance.#description || \"\")}`;\n\n          const flagsFromSubManager =\n            actualSubParserInstance && actualSubParserInstance.#flagManager\n              ? actualSubParserInstance.#flagManager.flags\n              : undefined;\n          const subFlags = (flagsFromSubManager || []).filter(\n            (f: ProcessedFlag) => f[\"name\"] !== \"help\",\n          );\n          if (subFlags.length > 0) {\n            subHelp += `\\n${indent(2)}${dim(\"Flags:\")}`;\n            subFlags\n              .sort((a: ProcessedFlag, b: ProcessedFlag) =>\n                a[\"name\"].localeCompare(b[\"name\"]),\n              )\n              .forEach((f: ProcessedFlag) => {\n                const flagOptions = f[\"options\"]\n                  .map((opt: string) => green(opt))\n                  .join(\", \");\n                const flagDesc = Array.isArray(f[\"description\"])\n                  ? f[\"description\"][0]\n                  : f[\"description\"];\n                subHelp += `\\n${indent(3)}${flagOptions} - ${dim(flagDesc)}`;\n              });\n          } else {\n            subHelp += `\\n${indent(2)}${dim(\"Flags:\")} none`;\n          }\n\n          const subSubCommandNames = Array.from(\n            actualSubParserInstance.#subCommands.keys(),\n          ); // Get keys from actualSubParserInstance's Map\n          if (subSubCommandNames.length > 0) {\n            subHelp += `\\n${indent(2)}${dim(\"Sub-commands:\")} ${subSubCommandNames.join(\", \")}`;\n          } else {\n            subHelp += `\\n${indent(2)}${dim(\"Sub-commands:\")} none`;\n          }\n\n          return subHelp;\n        })\n        .join(\"\\n\\n\");\n      help += \"\\n\";\n    }\n\n    help += `\\n${cyan(\"Flags:\")}\\n`;\n    const localFlags = this.#flagManager.flags; // Use FlagManager for local flags\n    if (localFlags.length > 0) {\n      help += localFlags\n        .sort((flagA, flagB) => flagA[\"name\"].localeCompare(flagB[\"name\"]))\n        .map((flag: ProcessedFlag) => {\n          // Flag type is ProcessedFlag\n          const optionsText = flag[\"options\"]\n            .toSorted((a: string, b: string) => a.length - b.length) // Sort by length (shortest first)\n            .map((opt: string) => green(opt))\n            .join(\", \");\n          const isMandatory =\n            typeof flag.mandatory === \"function\" ? \"dynamic\" : flag.mandatory;\n          const mandatoryIndicator =\n            isMandatory === true\n              ? ` ${red(this.#parameters.mandatoryCharacter)}`\n              : isMandatory === \"dynamic\"\n                ? ` ${dim(\"(conditionally mandatory)\")}`\n                : \"\";\n\n          const descriptionLines = Array.isArray(flag[\"description\"])\n            ? flag[\"description\"]\n            : [flag[\"description\"]];\n\n          const metaLines: string[] = [];\n\n          // Determine the type name for display\n          let typeName = \"unknown\";\n          if (typeof flag[\"type\"] === \"function\") {\n            typeName = flag[\"type\"].name || \"custom function\";\n            // Make the type names more user-friendly\n            if (typeName === \"Boolean\") typeName = \"boolean\";\n            if (typeName === \"String\") typeName = \"string\";\n            if (typeName === \"Number\") typeName = \"number\";\n            if (typeName === \"Array\") typeName = \"array\";\n            if (typeName === \"Object\") typeName = \"object\";\n          } else if (typeof flag[\"type\"] === \"string\") {\n            typeName = flag[\"type\"];\n          }\n\n          metaLines.push(`Type: ${typeName}`);\n\n          if (flag[\"flagOnly\"]) {\n            metaLines.push(\"Flag only (no value expected)\");\n          }\n          if (\n            flag[\"defaultValue\"] !== undefined &&\n            flag[\"defaultValue\"] !== null\n          ) {\n            metaLines.push(`Default: ${JSON.stringify(flag[\"defaultValue\"])}`);\n          }\n          if (flag[\"enum\"] && flag[\"enum\"].length > 0) {\n            metaLines.push(\n              `Allowed values: ${flag[\"enum\"].map((v: any) => `'${v}'`).join(\", \")}`,\n            );\n          }\n\n          const maxOptionLength = Math.max(\n            ...localFlags.map(\n              (f: ProcessedFlag) => f[\"options\"].join(\", \").length,\n            ),\n            0,\n          );\n          const formattedOptions =\n            optionsText.padEnd(maxOptionLength + 5) + mandatoryIndicator;\n\n          return `\n${indent()}${formattedOptions}\n${indent(2)}${white(descriptionLines[0])}\n${metaLines.map((line) => `${indent(3)}${dim(line)}`).join(\"\\n\")}\n${descriptionLines\n  .slice(1)\n  .map((line) => `\\n${indent(2)}${white(line)}`)\n  .join(\"\")}\n  `.trim();\n        })\n        .join(\"\\n\\n\");\n    } else {\n      help += `${indent()}${dim(\"none\")}`;\n    }\n\n    return help;\n  }\n\n  public getSubCommand(name: string): ISubCommand | undefined {\n    return this.#subCommands.get(name);\n  }\n\n  public hasFlag(name: string): boolean {\n    // Delegates to FlagManager\n    return this.#flagManager.hasFlag(name);\n  }\n\n  public getCommandChain(): string[] {\n    const chain = [];\n    let currentParser: ArgParser | undefined = this;\n    while (currentParser && currentParser.#parentParser) {\n      chain.unshift(currentParser.#subCommandName);\n      currentParser = currentParser.#parentParser;\n    }\n    return chain;\n  }\n\n  public getLastParseResult(): TParsedArgs<ProcessedFlag[]> {\n    return this.#lastParseResult;\n  }\n\n  #displayErrorAndExit(error: ArgParserError): void {\n    let commandNameToSuggest = \"your-script\";\n\n    if (this.#appCommandName) {\n      commandNameToSuggest = this.#appCommandName;\n    } else if (this.#appName && this.#appName !== \"Argument Parser\") {\n      commandNameToSuggest = this.#appName;\n    } else if (\n      typeof process !== \"undefined\" &&\n      process.argv &&\n      process.argv[1]\n    ) {\n      try {\n        commandNameToSuggest = path.basename(process.argv[1]);\n      } catch {}\n    }\n\n    const commandPath = [\n      commandNameToSuggest,\n      ...(error.commandChain || []),\n    ].join(\" \");\n\n    console.error(`\\n${chalk.red.bold(\"Error:\")} ${error.message}`);\n    console.error(\n      `\\n${chalk.dim(`Try '${commandPath} --help' for usage details.`)}`,\n    );\n\n    if (typeof process === \"object\" && typeof process.exit === \"function\") {\n      process.exit(1 as never);\n    } else {\n      throw error;\n    }\n  }\n\n  #_printRecursiveToConsole(\n    parser: ArgParser,\n    level: number,\n    visited: Set<ArgParser> = new Set(),\n  ): void {\n    const indent = \"  \".repeat(level);\n    const subIndent = \"  \".repeat(level + 1);\n    const flagIndent = \"  \".repeat(level + 2);\n\n    console.log(\n      `${indent}Parser: ${chalk.blueBright(parser.#subCommandName || parser.#appName)}`,\n    );\n    if (parser.#description) {\n      console.log(`${subIndent}Description: ${parser.#description}`);\n    }\n    console.log(`${subIndent}Options:`);\n    console.log(`${flagIndent}appName: ${parser.#appName}`);\n    console.log(\n      `${flagIndent}appCommandName: ${parser.#appCommandName ?? chalk.dim(\"undefined\")}`,\n    );\n    console.log(`${flagIndent}handleErrors: ${parser.#handleErrors}`);\n    console.log(\n      `${flagIndent}throwForDuplicateFlags: ${parser.#throwForDuplicateFlags}`,\n    );\n    console.log(\n      `${flagIndent}inheritParentFlags: ${parser.#inheritParentFlags}`,\n    );\n    console.log(`${flagIndent}Handler Defined: ${!!parser.#handler}`);\n    console.log(\n      `${subIndent}Internal Params: ${JSON.stringify(parser.#parameters)}`,\n    );\n\n    const flags = parser.#flagManager.flags;\n    if (flags.length > 0) {\n      console.log(`${subIndent}Flags (${flags.length}):`);\n      flags.forEach((flag: ProcessedFlag) => {\n        console.log(`${flagIndent}* ${chalk.green(flag[\"name\"])}:`);\n        console.log(`${flagIndent}  Options: ${flag[\"options\"].join(\", \")}`);\n        console.log(\n          `${flagIndent}  Description: ${Array.isArray(flag[\"description\"]) ? flag[\"description\"].join(\" | \") : flag[\"description\"]}`,\n        );\n        console.log(\n          `${flagIndent}  Type: ${typeof flag[\"type\"] === \"function\" ? flag[\"type\"].name || \"custom function\" : flag[\"type\"]}`,\n        );\n        console.log(\n          `${flagIndent}  Mandatory: ${typeof flag[\"mandatory\"] === \"function\" ? \"dynamic\" : (flag[\"mandatory\"] ?? false)}`,\n        );\n        console.log(\n          `${flagIndent}  Default: ${JSON.stringify(flag[\"defaultValue\"])}`,\n        );\n        console.log(`${flagIndent}  Flag Only: ${flag[\"flagOnly\"]}`);\n        console.log(`${flagIndent}  Allow Multiple: ${flag[\"allowMultiple\"]}`);\n        console.log(`${flagIndent}  Allow Ligature: ${flag[\"allowLigature\"]}`);\n        console.log(\n          `${flagIndent}  Enum: ${flag[\"enum\"] && flag[\"enum\"].length > 0 ? flag[\"enum\"].join(\", \") : \"none\"}`,\n        );\n        console.log(`${flagIndent}  Validator Defined: ${!!flag[\"validate\"]}`);\n      });\n    } else {\n      console.log(`${subIndent}Flags: ${chalk.dim(\"none\")}`);\n    }\n\n    const subCommandParsers = Array.from(parser.#subCommands.values());\n    if (subCommandParsers.length > 0) {\n      console.log(`${subIndent}Sub-Commands (${subCommandParsers.length}):`);\n      subCommandParsers.forEach((subCommand: any) => {\n        this.#_printRecursiveToConsole(subCommand.parser, level + 1, visited);\n      });\n    } else {\n      console.log(`${subIndent}Sub-Commands: ${chalk.dim(\"none\")}`);\n    }\n  }\n\n  #_buildRecursiveString(\n    parser: ArgParser,\n    level: number,\n    visited = new Set<ArgParser>(),\n  ): string {\n    // Add visited set\n    if (visited.has(parser)) return \"\"; // Prevent infinite loops for circular structures (if ever possible)\n    visited.add(parser);\n\n    let output = \"\";\n    const indent = \"  \".repeat(level);\n    const subIndent = \"  \".repeat(level + 1);\n    const flagIndent = \"  \".repeat(level + 2);\n\n    const addLine = (line: string) => {\n      output += line + \"\\\\n\";\n    };\n\n    addLine(\n      `${indent}Parser: ${parser.#subCommandName || parser.#appName}`, // #appName is guaranteed\n    );\n    if (parser.#description) {\n      addLine(`${subIndent}Description: ${parser.#description}`);\n    }\n    addLine(`${subIndent}Options:`);\n    addLine(`${flagIndent}appName: ${parser.#appName}`);\n    addLine(\n      `${flagIndent}appCommandName: ${parser.#appCommandName ?? \"undefined\"}`,\n    );\n    addLine(`${flagIndent}handleErrors: ${parser.#handleErrors}`);\n    addLine(\n      `${flagIndent}throwForDuplicateFlags: ${parser.#throwForDuplicateFlags}`,\n    );\n    addLine(`${flagIndent}inheritParentFlags: ${parser.#inheritParentFlags}`);\n    addLine(`${flagIndent}Handler Defined: ${!!parser.#handler}`);\n    addLine(\n      `${subIndent}Internal Params: ${JSON.stringify(parser.#parameters)}`,\n    );\n\n    const flags = parser.#flagManager.flags;\n    if (flags.length > 0) {\n      addLine(`${subIndent}Flags (${flags.length}):`);\n      flags.forEach((flag: ProcessedFlag) => {\n        addLine(`${flagIndent}* ${flag[\"name\"]}:`);\n        addLine(`${flagIndent}  Options: ${flag[\"options\"].join(\", \")}`);\n        addLine(\n          `${flagIndent}  Description: ${Array.isArray(flag[\"description\"]) ? flag[\"description\"].join(\" | \") : flag[\"description\"]}`,\n        );\n        let typeName = \"unknown\";\n        if (typeof flag[\"type\"] === \"function\") {\n          typeName = flag[\"type\"].name || \"custom function\";\n        } else if (typeof flag[\"type\"] === \"string\") {\n          typeName = flag[\"type\"];\n        } else if (typeof flag[\"type\"] === \"object\" && flag[\"type\"]) {\n          try {\n            typeName = (flag[\"type\"] as any).constructor?.name || \"object\";\n          } catch {\n            typeName = \"object\";\n          }\n        }\n        addLine(`${flagIndent}  Type: ${typeName}`);\n        addLine(\n          `${flagIndent}  Mandatory: ${typeof flag[\"mandatory\"] === \"function\" ? \"dynamic\" : (flag[\"mandatory\"] ?? false)}`,\n        );\n        addLine(\n          `${flagIndent}  Default: ${JSON.stringify(flag[\"defaultValue\"])}`,\n        );\n        addLine(`${flagIndent}  Flag Only: ${flag[\"flagOnly\"]}`);\n        addLine(`${flagIndent}  Allow Multiple: ${flag[\"allowMultiple\"]}`);\n        addLine(`${flagIndent}  Allow Ligature: ${flag[\"allowLigature\"]}`);\n        addLine(\n          `${flagIndent}  Enum: ${flag[\"enum\"] && flag[\"enum\"].length > 0 ? flag[\"enum\"].join(\", \") : \"none\"}`,\n        );\n        addLine(`${flagIndent}  Validator Defined: ${!!flag[\"validate\"]}`);\n      });\n    } else {\n      addLine(`${subIndent}Flags: none`);\n    }\n\n    const subCommandParsers = Array.from(parser.#subCommands.values());\n    if (subCommandParsers.length > 0) {\n      addLine(`${subIndent}Sub-Commands (${subCommandParsers.length}):`);\n      subCommandParsers.forEach((subCommand: any) => {\n        output += this.#_buildRecursiveString(\n          subCommand.parser,\n          level + 1,\n          visited,\n        );\n      });\n    } else {\n      addLine(`${subIndent}Sub-Commands: none`);\n    }\n    return output;\n  }\n\n  #_buildRecursiveJson(\n    parser: ArgParser,\n    visited = new Set<ArgParser>(),\n  ): object {\n    if (visited.has(parser))\n      return {\n        note: `Reference to already processed parser: ${parser.#subCommandName || parser.#appName}`,\n      };\n    visited.add(parser);\n\n    const config: any = {\n      parserName: parser.#subCommandName || parser.#appName, // #appName is guaranteed\n      description: parser.#description,\n      options: {\n        appName: parser.#appName,\n        appCommandName: parser.#appCommandName ?? undefined,\n        handleErrors: parser.#handleErrors,\n        throwForDuplicateFlags: parser.#throwForDuplicateFlags,\n        inheritParentFlags: parser.#inheritParentFlags,\n      },\n      handlerDefined: !!parser.#handler,\n      internalParams: parser.#parameters,\n      flags: [],\n      subCommands: {}, // Will be an object where keys are sub-command names\n    };\n\n    const flags = parser.#flagManager.flags;\n    config.flags = flags.map((flag: ProcessedFlag) => {\n      let typeName = \"unknown\";\n      if (typeof flag[\"type\"] === \"function\") {\n        typeName = flag[\"type\"].name || \"custom function\";\n      } else if (typeof flag[\"type\"] === \"string\") {\n        typeName = flag[\"type\"];\n      } else if (typeof flag[\"type\"] === \"object\" && flag[\"type\"]) {\n        try {\n          typeName = (flag[\"type\"] as any).constructor?.name || \"object\";\n        } catch {\n          typeName = \"object\";\n        }\n      }\n\n      return {\n        name: flag[\"name\"],\n        options: flag[\"options\"],\n        description: flag[\"description\"],\n        type: typeName,\n        mandatory:\n          typeof flag[\"mandatory\"] === \"function\"\n            ? \"dynamic\"\n            : (flag[\"mandatory\"] ?? false),\n        defaultValue: flag[\"defaultValue\"],\n        flagOnly: flag[\"flagOnly\"],\n        allowMultiple: flag[\"allowMultiple\"],\n        allowLigature: flag[\"allowLigature\"],\n        enum: flag[\"enum\"],\n        validatorDefined: !!flag[\"validate\"],\n      };\n    });\n\n    const subCommands = Array.from(parser.#subCommands.values());\n    if (subCommands.length > 0) {\n      subCommands.forEach((sub: any) => {\n        config.subCommands[sub.name] = this.#_buildRecursiveJson(\n          sub.parser,\n          visited,\n        );\n      });\n    }\n\n    return config;\n  }\n}\n"],"names":["_throwForDuplicateFlags","fs"],"mappings":"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"}