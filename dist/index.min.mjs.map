{"version":3,"file":"index.min.mjs","sources":["../__vite-browser-external","../src/types.ts","../src/FlagManager.ts","../src/ArgParser.ts"],"sourcesContent":["export default {}","import { z } from 'zod';\n\n// Forward declaration for ArgParser to avoid circular dependency in HandlerContext\n// This will be replaced or refined once ArgParser.ts is updated to use these types.\ntype ArgParserInstance = any;\n\nexport const zodFlagSchema = z\n  .object({\n    name: z\n      .string()\n      .min(1, \"Flag name cannot be empty\")\n      .describe(\n        \"The output property name, used as a return key `{name: value}`. Must be unique.\",\n      ),\n    allowLigature: z\n      .boolean()\n      .default(true)\n      .describe(\n        \"Enable both forms of flag input, e.g., `./script.js -f=value` and `-f value`.\",\n      ),\n    allowMultiple: z\n      .boolean()\n      .default(false)\n      .describe(\n        \"Allow passing the same flag multiple times, e.g., `-f val1 -f val2` results in an array.\",\n      ),\n    description: z\n      .union([z.string(), z.array(z.string())])\n      .describe(\"Textual description for help messages.\"),\n    options: z\n      .array(z.string().min(1))\n      .min(1, \"Flag must have at least one option (e.g., ['-f', '--flag'])\")\n      .describe(\"Array of option strings, e.g., ['-f', '--flag'].\"),\n    defaultValue: z\n      .any()\n      .optional()\n      .describe(\"Default value if the flag is not provided.\"),\n    type: z\n      .union([\n        z.any().refine((val) => val === String, { message: \"Must be String constructor\" }),\n        z.any().refine((val) => val === Number, { message: \"Must be Number constructor\" }),\n        z.any().refine((val) => val === Boolean, { message: \"Must be Boolean constructor\" }),\n        z.any().refine((val) => val === Array, { message: \"Must be Array constructor\" }),\n        z.any().refine((val) => val === Object, { message: \"Must be Object constructor\" }),\n        z.function().args(z.string()).returns(z.any()), // Custom parser function\n        z\n          .string()\n          .refine(\n            (value) =>\n              [\"boolean\", \"string\", \"number\", \"array\", \"object\"].includes(\n                value.toLowerCase(),\n              ),\n            { message: \"Invalid type string. Must be one of 'boolean', 'string', 'number', 'array', 'object'.\" },\n          ),\n      ])\n      .default(\"string\")\n      .describe(\"Expected data type or a custom parser function. Defaults to 'string'.\"),\n    mandatory: z\n      .union([z.boolean(), z.function().args(z.any()).returns(z.boolean())]) // `z.any()` for parsedArgs flexibility\n      .optional()\n      .describe(\"Makes the flag mandatory, can be a boolean or a function conditional on other args.\"),\n    flagOnly: z\n      .boolean()\n      .default(false)\n      .describe(\n        \"If true, the flag's presence is noted (true/false), and any subsequent value is not consumed by this flag.\",\n      ),\n    validate: z // User-provided validation function\n      .function()\n      .args(z.any().optional(), z.any().optional()) // value, parsedArgs?\n      .returns(z.union([z.boolean(), z.string(), z.void(), z.promise(z.union([z.boolean(), z.string(), z.void()]))]))\n      .optional()\n      .describe(\"Custom validation function for the flag's value (receives value, parsedArgs).\"),\n    enum: z // User-provided enum values\n      .array(z.any())\n      .optional()\n      .describe(\"Array of allowed values for the flag.\"),\n  })\n  .passthrough() // Allow unrecognized properties, they won't be validated or processed beyond alias handling.\n  .transform((obj) => {\n    const newObj: { [key: string]: any } = { ...obj };\n\n    if (\"default\" in newObj && newObj[\"default\"] !== undefined && !(\"defaultValue\" in newObj)) {\n      newObj[\"defaultValue\"] = newObj[\"default\"];\n    }\n\n    if (\"required\" in newObj && newObj[\"required\"] !== undefined && !(\"mandatory\" in newObj)) {\n      newObj[\"mandatory\"] = newObj[\"required\"] as boolean | ((parsedArgs: any) => boolean);\n    }\n\n    return newObj;\n  });\n\nexport type IFlagCore = z.input<typeof zodFlagSchema>;\n\nexport type IFlag = IFlagCore & {\n  /** @alias defaultValue */\n  default?: any;\n  /** @alias mandatory */\n  required?: boolean | ((parsedArgs: TParsedArgs<any>) => boolean); // `any` for now for TParsedArgs generic\n  // This handler seems to be for sub-commands, not specific to flag definition itself\n  // It was part of the original IFlag in ArgParser.ts.\n  // Consider moving to ISubCommand interface if it's only used there.\n  handler?: (ctx: HandlerContext) => void | Promise<void>;\n};\n\nexport type ProcessedFlagCore = z.output<typeof zodFlagSchema>;\n\nexport type ProcessedFlag = Omit<ProcessedFlagCore, \"type\" | \"validate\" | \"enum\" | \"mandatory\"> & {\n  type:\n    | StringConstructor\n    | NumberConstructor\n    | BooleanConstructor\n    | ArrayConstructor\n    | ObjectConstructor\n    | ((value: string) => any);\n  validate?: (\n    value: any,\n    parsedArgs?: TParsedArgs<ProcessedFlag[]>,\n  ) => boolean | string | void | Promise<boolean | string | void>;\n  enum?: any[];\n  mandatory?: boolean | ((parsedArgs: TParsedArgs<ProcessedFlag[]>) => boolean);\n};\n\nexport type ResolveType<T> = T extends (...args: any[]) => infer R\n  ? R // Function\n  : T extends new (...args: any[]) => infer S\n  ? S // Constructor\n  : T extends 'string' ? string\n  : T extends 'number' ? number\n  : T extends 'boolean' ? boolean\n  : T extends 'array' ? any[]\n  : T extends 'object' ? Record<string, any>\n  : any; // Fallback\n\nexport type ExtractFlagType<Flag extends ProcessedFlag> =\n  Flag[\"flagOnly\"] extends true\n    ? Flag[\"allowMultiple\"] extends true\n      ? boolean[] // Array of booleans if flagOnly and allowMultiple\n      : boolean   // Single boolean if flagOnly\n    : Flag[\"allowMultiple\"] extends true\n      ? Array<ResolveType<Flag[\"type\"]>> // Array of resolved type\n      : ResolveType<Flag[\"type\"]>;       // Single resolved type\n\nexport type TParsedArgs<Flags extends readonly (IFlag | ProcessedFlag)[]> = { // Made generic to support both IFlag and ProcessedFlag arrays\n  [K in Flags[number][\"name\"]]: Flags[number] extends ProcessedFlag // Type assertion to help compiler\n    ? ExtractFlagType<Extract<Flags[number], { name: K } & ProcessedFlag>>\n    : any; // Fallback for IFlag, though ideally, TParsedArgs uses ProcessedFlag\n};\n\n\nexport type HandlerContext = {\n  args: TParsedArgs<ProcessedFlag[]>;\n  parentArgs?: TParsedArgs<ProcessedFlag[]>;\n  commandChain: string[];\n  parser: ArgParserInstance; // Using the forward declared 'any' type\n};\n\n// Forward-declare ArgParser for ISubCommand to use\n// We use 'any' here as ArgParser itself imports types from this file,\n// creating a potential circular dependency for type-checking at this specific point.\n// The actual ArgParser<SubCmdFlags> type will be used in ArgParser.ts.\ntype ArgParserForSubcommand = any;\n\nexport interface ISubCommand {\n  name: string;\n  description?: string;\n  parser: ArgParserForSubcommand;\n  handler?: (ctx: HandlerContext) => void | Promise<void>;\n}\n\n// Generic type for the collection of flags an ArgParser instance will manage.\n// Using ProcessedFlag as these are the flags after initial validation and transformation.\nexport type FlagsArray = readonly ProcessedFlag[];","import { IFlag, ProcessedFlag, zodFlagSchema } from \"./types\";\n\nexport class FlagManager {\n  #_flags: Map<string, ProcessedFlag> = new Map();\n  #throwForDuplicateFlags: boolean;\n\n  constructor(\n    options: { throwForDuplicateFlags?: boolean } = {},\n    initialFlags: readonly IFlag[] = [],\n  ) {\n    this.#throwForDuplicateFlags = options.throwForDuplicateFlags ?? false;\n    this.addFlags(initialFlags);\n  }\n\n  static _safeFlag(flag: IFlag): ProcessedFlag {\n    const parsedFromZod = zodFlagSchema.parse(flag);\n\n    let resolvedType: ProcessedFlag[\"type\"];\n    const inputTypeFromZod = parsedFromZod[\"type\"];\n\n    if (typeof inputTypeFromZod === \"string\") {\n      switch (inputTypeFromZod.toLowerCase()) {\n        case \"boolean\":\n          resolvedType = Boolean;\n          break;\n        case \"string\":\n          resolvedType = String;\n          break;\n        case \"number\":\n          resolvedType = Number;\n          break;\n        case \"array\":\n          resolvedType = Array;\n          break;\n        case \"object\":\n          resolvedType = Object;\n          break;\n        default:\n          throw new Error(`Invalid type string: ${inputTypeFromZod}`);\n      }\n    } else {\n      resolvedType = inputTypeFromZod as ProcessedFlag[\"type\"];\n    }\n\n    return {\n      ...parsedFromZod,\n      options: parsedFromZod[\"options\"],\n      type: resolvedType,\n      validate: parsedFromZod[\"validate\"],\n      enum: parsedFromZod[\"enum\"],\n      mandatory: parsedFromZod[\"mandatory\"],\n    };\n  }\n\n  addFlag(flag: IFlag): this {\n    const safeFlag = FlagManager._safeFlag(flag);\n\n    if (this.#_flags.has(safeFlag[\"name\"])) {\n      if (this.#throwForDuplicateFlags) {\n        throw new Error(\n          `FlagManager: Flag '${safeFlag[\"name\"]}' already exists.`,\n        );\n      } else {\n        console.warn(\n          `Warning: FlagManager: Flag '${safeFlag[\"name\"]}' already exists. Duplicate not added.`,\n        );\n        return this;\n      }\n    }\n\n    this.#_flags.set(safeFlag[\"name\"], safeFlag);\n    return this;\n  }\n\n  _setProcessedFlagForInheritance(processedFlag: ProcessedFlag): this {\n    if (this.#_flags.has(processedFlag[\"name\"])) {\n      return this;\n    }\n    this.#_flags.set(processedFlag[\"name\"], processedFlag);\n    return this;\n  }\n\n  addFlags(flags: readonly IFlag[]): this {\n    for (const flag of flags) {\n      this.addFlag(flag);\n    }\n    return this;\n  }\n\n  hasFlag(name: string): boolean {\n    return this.#_flags.has(name);\n  }\n\n  getFlag(name: string): ProcessedFlag | undefined {\n    return this.#_flags.get(name);\n  }\n\n  get flags(): ProcessedFlag[] {\n    return Array.from(this.#_flags.values());\n  }\n\n  get flagNames(): string[] {\n    return Array.from(this.#_flags.values()).map((flag) => flag[\"name\"]);\n  }\n}\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport chalk from \"chalk\";\nimport { anyOf, char, createRegExp, oneOrMore } from \"magic-regexp\";\nimport { FlagManager } from \"./FlagManager\";\nimport {\n  HandlerContext,\n  IFlag,\n  ISubCommand,\n  ProcessedFlag,\n  TParsedArgs,\n} from \"./types\";\n\nexport class ArgParserError extends Error {\n  public commandChain: string[];\n  constructor(\n    message: string,\n    public cmdChain: string[] = [],\n  ) {\n    super(message);\n    this.name = \"ArgParserError\";\n    this.commandChain = cmdChain;\n  }\n}\n\n// zodFlagSchema, IFlag (zod-derived), ResolveType, ExtractFlagType, TParsedArgs (original)\n// have been moved to types.ts or are superseded by types from types.ts\n\ninterface IArgParserParams {\n  /**\n   * Add an extra new line between each flag group,\n   * makes the text more readable but uses more space\n   *\n   * Default: true\n   */\n  extraNewLine?: boolean;\n  /**\n   * Wraps the line at width, if shorter, wrapping will be more\n   * aggressive. Wrapping is based on words.\n   *\n   * Default: 50\n   * Minimum: 30\n   */\n  wrapAtWidth?: number;\n  /**\n   * Controls the placing of right text on the screen.\n   * The higher the value, the more to the right the text will be.\n   *\n   * Default: 30\n   * Minimum: 20\n   */\n  blankSpaceWidth?: number;\n  /**\n   * Character to display next to the flag to express mandatory fields.\n   *\n   * Default: *\n   */\n  mandatoryCharacter?: string;\n  /**\n   * Throw an error if a flag is added more than once\n   * @default false\n   */\n  throwForDuplicateFlags?: boolean;\n  description?: string; // New property for the description\n  /**\n   * Automatically handle ArgParserErrors by printing a formatted message\n   * and exiting. Set to false to catch ArgParserError manually.\n   * @default true\n   */\n  handleErrors?: boolean;\n  /**\n   * The command name to display in help suggestions (e.g., 'dabl').\n   * If not provided, it falls back to appName or guessing from the script path.\n   * @since 1.5.1\n   */\n  appCommandName?: string;\n  /**\n   * If true, when this parser is added as a sub-command, it will inherit\n   * flags from its direct parent *unless* a flag with the same name\n   * already exists in this parser. Child flags take precedence.\n   * @default false\n   */\n  inheritParentFlags?: boolean;\n}\n\ninterface IParseOptions {\n  /**\n   * When true, skips help flag processing (doesn't exit or show help)\n   * @default false\n   */\n  skipHelpHandling?: boolean;\n  /**\n   * When true, skips the execution of any command handlers.\n   * @default false\n   */\n  skipHandlers?: boolean;\n}\n\ntype TParsedArgsWithRouting<T = any> = T & {\n  $commandChain?: string[];\n  handlerToExecute?: { handler: Function; context: HandlerContext };\n};\n\ntype RecursiveParseResult = {\n  finalArgs: TParsedArgsWithRouting<any>;\n  handlerToExecute?: { handler: Function; context: HandlerContext };\n};\n\nexport class ArgParser {\n  #appName: string = \"Argument Parser\";\n  #appCommandName?: string;\n  #subCommandName: string = \"\";\n  #parameters: IArgParserParams = {\n    extraNewLine: true,\n    wrapAtWidth: 50,\n    blankSpaceWidth: 30,\n    mandatoryCharacter: \"*\",\n  };\n  #handler?: (ctx: HandlerContext) => void;\n  #throwForDuplicateFlags: boolean = false;\n  #description?: string;\n  #handleErrors: boolean = true;\n  #parentParser?: ArgParser;\n  #lastParseResult: TParsedArgs<ProcessedFlag[]> = {};\n  #inheritParentFlags: boolean = false;\n  #subCommands: Map<string, ISubCommand> = new Map();\n  #flagManager: FlagManager;\n\n  constructor(\n    options: IArgParserParams & {\n      appName?: string;\n      subCommands?: ISubCommand[];\n      handler?: (ctx: HandlerContext) => void;\n    } = {},\n    initialFlags?: readonly IFlag[],\n  ) {\n    this.#appName = options.appName || \"app\";\n    if (\n      options.blankSpaceWidth &&\n      !isNaN(Number(options.blankSpaceWidth)) &&\n      Number(options.blankSpaceWidth) > 20\n    )\n      this.#parameters.blankSpaceWidth = Number(options.blankSpaceWidth);\n\n    if (\n      options.wrapAtWidth &&\n      !isNaN(Number(options.wrapAtWidth)) &&\n      Number(options.wrapAtWidth) > 30\n    )\n      this.#parameters.wrapAtWidth = Number(options.wrapAtWidth);\n\n    if (typeof options.extraNewLine === \"boolean\")\n      this.#parameters.extraNewLine = Boolean(options.extraNewLine);\n\n    if (typeof options.mandatoryCharacter === \"string\")\n      this.#parameters.mandatoryCharacter = options.mandatoryCharacter;\n\n    if (typeof options.throwForDuplicateFlags === \"boolean\")\n      this.#throwForDuplicateFlags = options.throwForDuplicateFlags;\n\n    this.#flagManager = new FlagManager(\n      {\n        throwForDuplicateFlags: this.#throwForDuplicateFlags,\n      },\n      initialFlags || [],\n    );\n\n    this.#handleErrors = options.handleErrors ?? true;\n    this.#inheritParentFlags = options.inheritParentFlags ?? false;\n    this.#description = options.description;\n    this.#handler = options.handler;\n    this.#appCommandName = options.appCommandName;\n\n    const helpFlag: IFlag = {\n      name: \"help\",\n      description: \"Display this help message and exits\",\n      mandatory: false,\n      type: Boolean,\n      options: [\"-h\", \"--help\"],\n      defaultValue: undefined,\n      allowLigature: false,\n      allowMultiple: false,\n      flagOnly: true,\n      enum: [],\n      validate: (_value?: any, _parsedArgs?: any) => true, // Ensure signature matches Zod schema for .args()\n    };\n    this.#flagManager.addFlag(helpFlag); // Add the help flag via FlagManager\n\n    if (options.subCommands) {\n      for (const sub of options.subCommands) {\n        this.addSubCommand(sub);\n      }\n    }\n  }\n\n  get flags(): ProcessedFlag[] {\n    return this.#flagManager.flags;\n  }\n\n  get flagNames(): string[] {\n    return this.#flagManager.flagNames; // Delegates to FlagManager\n  }\n\n  private _addToOutput(\n    flag: ProcessedFlag, // Changed from Flags[number]\n    arg: any,\n    output: TParsedArgs<ProcessedFlag[]>,\n    _parseOptions?: IParseOptions,\n  ) {\n    let value: unknown = arg;\n\n    if (flag.type === Boolean) {\n      if (typeof arg === \"boolean\") {\n        value = arg;\n      } else if (typeof arg === \"string\") {\n        value = /(true|yes|1)/i.test(arg);\n      } else {\n        value = new (flag[\"type\"] as ObjectConstructor)(value);\n      }\n    } else if (typeof flag[\"type\"] === \"function\") {\n      value = (flag[\"type\"] as Function)(value as string);\n    } else if (typeof flag[\"type\"] === \"object\") {\n      value = new (flag[\"type\"] as ObjectConstructor)(value);\n    }\n\n    if (flag[\"enum\"] && flag[\"enum\"].length > 0) {\n      const allowedValues = flag[\"enum\"]\n        .map((v: any) => (typeof v === \"string\" ? `'${v}'` : v))\n        .join(\", \");\n\n      if (!flag[\"enum\"].includes(value)) {\n        throw new ArgParserError(\n          `Invalid value '${value}' for flag '${chalk.yellow(flag[\"name\"])}'. ` +\n            `Allowed values: ${allowedValues}`,\n          this.getCommandChain(),\n        );\n      }\n    }\n\n    if (flag[\"validate\"]) {\n      const validationResult = flag[\"validate\"](value, output);\n      if (validationResult === false) {\n        throw new ArgParserError(\n          `Validation failed for flag '${chalk.yellow(flag[\"name\"])}' with value '${value}'`,\n          this.getCommandChain(),\n        );\n      } else if (typeof validationResult === \"string\") {\n        throw new ArgParserError(validationResult, this.getCommandChain());\n      }\n    }\n\n    if (flag[\"allowMultiple\"] && !Array.isArray(output[flag[\"name\"]])) {\n      output[flag[\"name\"]] = [] as any;\n    }\n\n    return flag[\"allowMultiple\"]\n      ? (output[flag[\"name\"]] as any[]).push(value)\n      : (output[flag[\"name\"]] = value as any);\n  }\n\n  addFlags(flags: readonly IFlag[]): this {\n    this.#flagManager.addFlags(flags);\n    return this;\n  }\n\n  addFlag(flag: IFlag): this {\n    this.#flagManager.addFlag(flag);\n    return this;\n  }\n\n  addSubCommand(subCommandConfig: ISubCommand): this {\n    if (this.#subCommands.has(subCommandConfig.name)) {\n      throw new Error(`Sub-command '${subCommandConfig.name}' already exists`);\n    }\n\n    const subParser = subCommandConfig.parser;\n\n    if (!(subParser instanceof ArgParser)) {\n      throw new Error(\n        `Parser for subcommand '${subCommandConfig.name}' is not an instance of ArgParser. ` +\n          `Please provide 'new ArgParser(...)' for the 'parser' property of an ISubCommand.`,\n      );\n    }\n\n    subParser.#parentParser = this;\n    subParser.#subCommandName = subCommandConfig.name;\n    if (!subParser.#appCommandName && this.#appCommandName) {\n      subParser.#appCommandName = this.#appCommandName;\n    }\n\n    if (subParser.#inheritParentFlags) {\n      const parentFlags = this.#flagManager.flags;\n      for (const parentFlag of parentFlags) {\n        if (!subParser.#flagManager.hasFlag(parentFlag[\"name\"])) {\n          subParser.#flagManager._setProcessedFlagForInheritance(parentFlag);\n        }\n      }\n    }\n\n    this.#subCommands.set(subCommandConfig.name, subCommandConfig);\n\n    if (subCommandConfig.handler) {\n      subParser.setHandler(subCommandConfig.handler);\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the handler function for this specific parser instance.\n   * This handler will be executed if this parser is the final one\n   * in the command chain and `executeHandlers` is enabled on the root parser.\n   *\n   * @param handler - The function to execute.\n   * @returns The ArgParser instance for chaining.\n   */\n  setHandler(handler: (ctx: HandlerContext) => void): this {\n    this.#handler = handler;\n    return this;\n  }\n\n  printAll(filePath?: string): void {\n    if (filePath) {\n      try {\n        const dir = path.dirname(filePath);\n        if (!fs.existsSync(dir)) {\n          fs.mkdirSync(dir, { recursive: true });\n        }\n\n        if (filePath.toLowerCase().endsWith(\".json\")) {\n          const outputObject = this.#_buildRecursiveJson(this);\n          const jsonString = JSON.stringify(outputObject, null, 2);\n          fs.writeFileSync(filePath, jsonString);\n          console.log(`ArgParser configuration JSON dumped to: ${filePath}`);\n        } else {\n          const outputString = this.#_buildRecursiveString(this, 0);\n          const plainText = outputString.replace(\n            /[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,\n            \"\",\n          );\n          fs.writeFileSync(filePath, plainText);\n          console.log(`ArgParser configuration text dumped to: ${filePath}`);\n        }\n      } catch (error) {\n        console.error(\n          `Error writing ArgParser configuration to file '${filePath}':`,\n          error,\n        );\n      }\n    } else {\n      console.log(\"\\n--- ArgParser Configuration Dump ---\");\n      this.#_printRecursiveToConsole(this, 0);\n      console.log(\"--- End Configuration Dump ---\\\\n\");\n    }\n  }\n\n  #_identifyCommandChainAndParsers(\n    argsToParse: string[],\n    currentParser: ArgParser,\n    commandChainSoFar: string[],\n    parserChainSoFar: ArgParser[],\n  ): {\n    finalParser: ArgParser;\n    commandChain: string[];\n    parserChain: ArgParser[];\n    remainingArgs: string[];\n  } {\n    let subCommandIndex = -1;\n    let subCommandName: string | null = null;\n\n    for (let i = 0; i < argsToParse.length; i++) {\n      const potentialSubCommand = argsToParse[i];\n      if (currentParser.#subCommands.has(potentialSubCommand)) {\n        subCommandIndex = i;\n        subCommandName = potentialSubCommand;\n        break;\n      }\n    }\n\n    if (subCommandIndex === -1 || subCommandName === null) {\n      return {\n        finalParser: currentParser,\n        commandChain: commandChainSoFar,\n        parserChain: parserChainSoFar,\n        remainingArgs: argsToParse,\n      };\n    }\n\n    const subCommandConfig = currentParser.#subCommands.get(subCommandName);\n    if (!subCommandConfig || !(subCommandConfig.parser instanceof ArgParser)) {\n      throw new Error(\n        `Internal error: Subcommand '${subCommandName!}' configuration is invalid or parser is missing.`,\n      );\n    }\n    const nextParser = subCommandConfig.parser;\n    const nextArgs = argsToParse.slice(subCommandIndex + 1);\n    const nextCommandChain = [...commandChainSoFar, subCommandName];\n    const nextParserChain = [...parserChainSoFar, nextParser];\n\n    return this.#_identifyCommandChainAndParsers(\n      nextArgs,\n      nextParser,\n      nextCommandChain,\n      nextParserChain,\n    );\n  }\n\n  #_handleGlobalChecks(\n    processArgs: string[],\n    options?: IParseOptions,\n  ): boolean {\n    if (processArgs.length === 0 && !this.#parentParser && !this.#handler) {\n      console.log(this.helpText());\n      if (typeof process === \"object\" && typeof process.exit === \"function\") {\n        process.exit(0 as never);\n      }\n      return true;\n    }\n\n    if (processArgs.includes(\"--LIB-debug-print\")) {\n      this.printAll(\"ArgParser.full.json\");\n      if (typeof process === \"object\" && typeof process.exit === \"function\") {\n        process.exit(0);\n      }\n      return true;\n    }\n\n    const { finalParser: identifiedFinalParser } =\n      this.#_identifyCommandChainAndParsers(processArgs, this, [], [this]);\n\n    if (processArgs.includes(\"--LIB-debug\")) {\n      console.log(\n        chalk.yellow.bold(\"\\n--- ArgParser --LIB-debug Runtime Context ---\"),\n      );\n\n      const {\n        commandChain: identifiedCommandChain,\n        parserChain: _identifiedParserChain,\n      } = this.#_identifyCommandChainAndParsers(processArgs, this, [], [this]);\n\n      console.log(\n        `Identified Command Chain: ${chalk.cyan(identifiedCommandChain.join(\" -> \") || \"(root)\")}`,\n      );\n      console.log(\n        `Identified Final Parser: ${chalk.cyan(identifiedFinalParser.#subCommandName || identifiedFinalParser.#appName)}`,\n      );\n\n      let currentParser: ArgParser = this;\n      let remainingArgs = [...processArgs];\n      let accumulatedArgs: TParsedArgs<any> = {};\n      const parsingSteps: {\n        level: string;\n        argsSlice: string[];\n        parsed?: TParsedArgs<any>;\n        error?: string;\n      }[] = [];\n\n      const rootSubCommandIndex = remainingArgs.findIndex((arg) =>\n        currentParser.#subCommands.has(arg),\n      );\n      const rootArgsSlice =\n        rootSubCommandIndex === -1\n          ? remainingArgs\n          : remainingArgs.slice(0, rootSubCommandIndex);\n      parsingSteps.push({ level: \"(root)\", argsSlice: rootArgsSlice });\n      try {\n        const { parsedArgs: rootParsedArgs } = currentParser.#parseFlags(\n          rootArgsSlice,\n          { skipHelpHandling: true },\n        );\n        parsingSteps[0].parsed = rootParsedArgs;\n        accumulatedArgs = { ...accumulatedArgs, ...rootParsedArgs };\n      } catch (e: any) {\n        parsingSteps[0].error = e.message;\n      }\n      remainingArgs =\n        rootSubCommandIndex === -1\n          ? []\n          : remainingArgs.slice(rootSubCommandIndex);\n\n      for (let i = 0; i < identifiedCommandChain.length; i++) {\n        const subCommandName = identifiedCommandChain[i];\n        if (!currentParser.#subCommands.has(subCommandName)) {\n          parsingSteps.push({\n            level: `Error`,\n            argsSlice: [],\n            error: `Could not find sub-command parser for '${subCommandName}'`,\n          });\n          break;\n        }\n        currentParser = currentParser.#subCommands.get(subCommandName)?.parser;\n        remainingArgs = remainingArgs.slice(1);\n\n        const nextSubCommandIndex = remainingArgs.findIndex((arg) =>\n          currentParser.#subCommands.has(arg),\n        );\n        const currentLevelArgsSlice =\n          nextSubCommandIndex === -1\n            ? remainingArgs\n            : remainingArgs.slice(0, nextSubCommandIndex);\n        const stepInfo: {\n          level: string;\n          argsSlice: string[];\n          parsed?: TParsedArgs<any>;\n          error?: string;\n        } = {\n          level: subCommandName,\n          argsSlice: currentLevelArgsSlice,\n        };\n        parsingSteps.push(stepInfo);\n\n        try {\n          const { parsedArgs: currentLevelParsedArgs } =\n            currentParser.#parseFlags(currentLevelArgsSlice, {\n              skipHelpHandling: true,\n            });\n          stepInfo.parsed = currentLevelParsedArgs;\n          accumulatedArgs = { ...accumulatedArgs, ...currentLevelParsedArgs };\n        } catch (e: any) {\n          stepInfo.error = e.message;\n        }\n        remainingArgs =\n          nextSubCommandIndex === -1\n            ? []\n            : remainingArgs.slice(nextSubCommandIndex);\n      }\n\n      console.log(chalk.yellow(\"\\nParsing Simulation Steps:\"));\n      parsingSteps.forEach((step) => {\n        console.log(`  Level: ${chalk.cyan(step.level)}`);\n        console.log(\n          `    Args Slice Considered: ${JSON.stringify(step.argsSlice)}`,\n        );\n        if (step.parsed) {\n          console.log(\n            `    Parsed Args at this Level: ${JSON.stringify(step.parsed)}`,\n          );\n        }\n        if (step.error) {\n          console.log(\n            `    ${chalk.red(\"Error during parse simulation:\")} ${step.error}`,\n          );\n        }\n      });\n\n      console.log(\n        chalk.yellow(\n          \"\\nFinal Accumulated Args State (before final validation):\",\n        ),\n      );\n      console.log(JSON.stringify(accumulatedArgs, null, 2));\n\n      console.log(chalk.yellow(\"\\nArguments Remaining After Simulation:\"));\n      console.log(JSON.stringify(remainingArgs, null, 2));\n\n      console.log(\n        chalk.yellow.bold(\n          \"\\n--- ArgParser Static Configuration (Final Parser) ---\",\n        ),\n      );\n      identifiedFinalParser.printAll();\n\n      console.log(chalk.yellow.bold(\"--- End ArgParser --LIB-debug ---\"));\n      if (typeof process === \"object\" && typeof process.exit === \"function\") {\n        process.exit(0);\n      }\n      return true;\n    }\n\n    // ---- BEGIN ADDED DIAGNOSTIC LOG FOR identifiedFinalParser ----\n    let parserNameForLog = \"undefined_parser\";\n    if (identifiedFinalParser instanceof ArgParser) {\n      // Access private fields only if it's a confirmed ArgParser instance\n      parserNameForLog =\n        (identifiedFinalParser as any)[\"#subCommandName\"] ||\n        (identifiedFinalParser as any)[\"#appName\"];\n    } else if (identifiedFinalParser) {\n      parserNameForLog =\n        (identifiedFinalParser as any).name ||\n        (identifiedFinalParser as any).appName ||\n        \"unknown_type\";\n    }\n    // console.log(\n    //   `[ArgParser #_handleGlobalChecks Debug] identifiedFinalParser: constructor=${identifiedFinalParser ? 'defined' : 'undefined'}, isArgParser=${identifiedFinalParser instanceof ArgParser}, name=${parserNameForLog}`\n    // );\n    // ---- END ADDED DIAGNOSTIC LOG FOR identifiedFinalParser ----\n\n    // ---- BEGIN GUARD FOR identifiedFinalParser ----\n    if (!(identifiedFinalParser instanceof ArgParser)) {\n      console.error(\n        `[ArgParser #_handleGlobalChecks Critical Error] identifiedFinalParser is not an instance of ArgParser. Cannot process help. Name: ${parserNameForLog}, Constructor: ${identifiedFinalParser ? (identifiedFinalParser as any).constructor?.name : \"undefined\"}`,\n      );\n      // Returning false to prevent further processing with an invalid parser,\n      // which could lead to more cryptic errors or incorrect behavior.\n      return false;\n    }\n    // ---- END GUARD FOR identifiedFinalParser ----\n\n    const helpFlagDefinition =\n      identifiedFinalParser.#flagManager.getFlag(\"help\");\n    if (helpFlagDefinition && !options?.skipHelpHandling) {\n      const helpOptions = helpFlagDefinition[\"options\"];\n\n      // ---- BEGIN ADDED DEBUG AND DEFENSIVE CHECK ----\n      // if (!Array.isArray(helpOptions) || helpOptions.length === 0) {\n      //   console.warn(\n      //     `[ArgParser Debug] helpOptions is not a valid array or is empty. Value: ${JSON.stringify(helpOptions)}, Type: ${typeof helpOptions}`,\n      //     `Parser: ${parserNameForLog}`, // Use the determined parserNameForLog\n      //   );\n      //   // Potentially, we might even want to return false here or throw,\n      //   // as help cannot be processed correctly. For now, just log and continue.\n      // } else {\n      //   // Optional: Log the valid helpOptions for debugging successful cases\n      //   // console.log(`[ArgParser Debug] Valid helpOptions: ${JSON.stringify(helpOptions)} for parser ${parserNameForLog}`);\n      // }\n      // ---- END ADDED DEBUG AND DEFENSIVE CHECK ----\n\n      const helpRequested = processArgs.some((arg) =>\n        helpOptions.includes(arg),\n      );\n\n      if (helpRequested) {\n        console.log(identifiedFinalParser.helpText());\n        if (typeof process === \"object\" && typeof process.exit === \"function\") {\n          process.exit(0 as never);\n        }\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  #_validateMandatoryFlags(\n    finalArgs: TParsedArgsWithRouting<any>,\n    parserChain: ArgParser[],\n    commandChain: string[],\n  ): void {\n    const finalMandatoryFlagsMissing: {\n      name: string;\n      parserName: string;\n      commandChain: string[];\n    }[] = [];\n    const checkedFlagNames = new Set<string>();\n\n    for (const parser of parserChain) {\n      const currentCommandChain = parser.getCommandChain();\n      for (const flag of parser.#flagManager.flags) {\n        // Use FlagManager\n        if (flag[\"name\"] === \"help\" || checkedFlagNames.has(flag[\"name\"]))\n          continue;\n\n        const isMandatory =\n          typeof flag[\"mandatory\"] === \"function\"\n            ? flag[\"mandatory\"](finalArgs)\n            : flag[\"mandatory\"];\n\n        if (!isMandatory) continue;\n\n        const value = finalArgs[flag[\"name\"] as keyof typeof finalArgs];\n        let currentFlagIsMissing = false;\n\n        if (flag[\"allowMultiple\"]) {\n          // For allowMultiple, it's missing if undefined OR an empty array\n          if (\n            value === undefined ||\n            (Array.isArray(value) && value.length === 0)\n          ) {\n            currentFlagIsMissing = true;\n          }\n        } else {\n          // For non-allowMultiple, it's missing if undefined\n          if (value === undefined) {\n            currentFlagIsMissing = true;\n          }\n        }\n\n        if (currentFlagIsMissing) {\n          if (!checkedFlagNames.has(flag[\"name\"])) {\n            finalMandatoryFlagsMissing.push({\n              name: flag[\"name\"],\n              parserName: parser.#subCommandName || parser.#appName,\n              commandChain: currentCommandChain,\n            });\n            checkedFlagNames.add(flag[\"name\"]);\n          }\n        }\n      }\n    }\n\n    if (finalMandatoryFlagsMissing.length > 0) {\n      throw new ArgParserError(\n        `Missing mandatory flags: ${finalMandatoryFlagsMissing\n          .map((flag) => chalk.yellow(flag[\"name\"]))\n          .join(\", \")}`,\n        commandChain,\n      );\n    }\n  }\n\n  #_applyDefaultValues(\n    finalArgs: TParsedArgsWithRouting<any>,\n    finalParser: ArgParser,\n  ): void {\n    for (const flag of finalParser.#flagManager.flags) {\n      // Use FlagManager\n      const flagName = flag[\"name\"] as string;\n      if (\n        finalArgs[flagName] === undefined &&\n        flag[\"defaultValue\"] !== undefined\n      ) {\n        if (flag[\"allowMultiple\"]) {\n          finalArgs[flagName] = Array.isArray(flag[\"defaultValue\"])\n            ? flag[\"defaultValue\"]\n            : [flag[\"defaultValue\"]];\n        } else {\n          finalArgs[flagName] = flag[\"defaultValue\"];\n        }\n      }\n    }\n  }\n\n  #_prepareAndExecuteHandler(\n    handlerToExecute: RecursiveParseResult[\"handlerToExecute\"],\n    finalArgs: TParsedArgsWithRouting<any>,\n    skipHandlers: boolean,\n  ): void {\n    if (skipHandlers || !handlerToExecute) {\n      return;\n    }\n\n    const finalParserWhoseHandlerWillRun = handlerToExecute.context.parser;\n    const finalParserFlags = finalParserWhoseHandlerWillRun.#flagManager.flags;\n    const handlerArgs = handlerToExecute.context.args;\n\n    for (const flag of finalParserFlags) {\n      const flagName = flag[\"name\"] as keyof typeof finalArgs;\n      if (finalArgs.hasOwnProperty(flagName)) {\n        (handlerArgs as any)[flagName] = (finalArgs as any)[flagName];\n      } else if (\n        flag[\"allowMultiple\"] &&\n        !handlerArgs.hasOwnProperty(flagName)\n      ) {\n        (handlerArgs as any)[flagName] = [];\n      }\n    }\n    handlerToExecute.context.args = handlerArgs;\n\n    handlerToExecute.handler(handlerToExecute.context);\n  }\n\n  parse(\n    processArgs: string[],\n    options?: IParseOptions,\n  ): TParsedArgsWithRouting<any> {\n    if (this.#_handleGlobalChecks(processArgs, options)) {\n      return {} as TParsedArgsWithRouting<any>;\n    }\n\n    try {\n      const {\n        finalParser: identifiedFinalParser,\n        commandChain: identifiedCommandChain,\n        parserChain: identifiedParserChain,\n      } = this.#_identifyCommandChainAndParsers(processArgs, this, [], [this]);\n\n      const { finalArgs, handlerToExecute } = this._parseRecursive(\n        processArgs,\n        this,\n        {},\n        [],\n        options,\n      );\n\n      // Set command chain in final args\n      if (identifiedCommandChain.length > 0) {\n        (finalArgs as any).$commandChain = identifiedCommandChain;\n      }\n\n      this.#_validateMandatoryFlags(\n        finalArgs,\n        identifiedParserChain,\n        identifiedCommandChain,\n      );\n\n      this.#_applyDefaultValues(finalArgs, identifiedFinalParser);\n\n      this.#_prepareAndExecuteHandler(\n        handlerToExecute,\n        finalArgs,\n        options?.skipHandlers ?? false,\n      );\n\n      return finalArgs;\n    } catch (error) {\n      if (error instanceof ArgParserError) {\n        if (this.#handleErrors) {\n          this.#displayErrorAndExit(error);\n          return {} as TParsedArgsWithRouting<any>;\n        } else {\n          throw error;\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Recursive helper for parsing arguments and handling sub-commands.\n   * This method assumes the global help check has already been performed in `parse`.\n   */\n  private _parseRecursive(\n    argsToParse: string[],\n    currentParser: ArgParser,\n    accumulatedParentArgs: TParsedArgs<any>,\n    commandChainSoFar: string[],\n    options?: IParseOptions,\n  ): RecursiveParseResult {\n    let subCommandIndex = -1;\n    let subCommandName: string | null = null;\n\n    // Find the index of the first argument that matches a defined sub-command name\n    for (let i = 0; i < argsToParse.length; i++) {\n      const potentialSubCommand = argsToParse[i];\n      if (currentParser.#subCommands.has(potentialSubCommand)) {\n        subCommandIndex = i;\n        subCommandName = potentialSubCommand;\n        break;\n      }\n    }\n\n    // Determine which arguments belong to the current parser level\n    const argsForCurrentLevel =\n      subCommandIndex === -1\n        ? argsToParse\n        : argsToParse.slice(0, subCommandIndex);\n\n    // Parse flags for the current level using #parseFlags\n    const { parsedArgs: currentLevelArgs, firstUnconsumedIndex } =\n      currentParser.#parseFlags(argsForCurrentLevel, options);\n\n    // Apply default values for the current parser's flags to its args\n    currentParser.#_applyDefaultValues(currentLevelArgs, currentParser);\n\n    const combinedArgsFromThisAndParents = {\n      ...accumulatedParentArgs,\n      ...currentLevelArgs,\n    };\n\n    if (subCommandIndex === -1 || subCommandName === null) {\n      if (firstUnconsumedIndex < argsForCurrentLevel.length) {\n        const unknownCommand = argsForCurrentLevel[firstUnconsumedIndex];\n        throw new ArgParserError(\n          `Unknown command: '${chalk.yellow(unknownCommand)}'`,\n          commandChainSoFar,\n        );\n      }\n\n      const finalParseResultArgs = { ...combinedArgsFromThisAndParents };\n      if (commandChainSoFar.length > 0) {\n        finalParseResultArgs[\"$commandChain\"] = commandChainSoFar;\n      }\n\n      let handlerToExecute: RecursiveParseResult[\"handlerToExecute\"] =\n        undefined;\n      if (currentParser.#handler) {\n        handlerToExecute = {\n          handler: currentParser.#handler,\n          context: {\n            args: currentLevelArgs,\n            parentArgs: accumulatedParentArgs,\n            commandChain: commandChainSoFar,\n            parser: currentParser,\n          },\n        };\n      }\n      return { finalArgs: finalParseResultArgs, handlerToExecute };\n    }\n    if (firstUnconsumedIndex < argsForCurrentLevel.length) {\n      const unknownCommand = argsForCurrentLevel[firstUnconsumedIndex];\n      throw new ArgParserError(\n        `Unknown command: '${chalk.yellow(unknownCommand)}'`,\n        commandChainSoFar,\n      );\n    }\n\n    const subCommandConfig = currentParser.#subCommands.get(subCommandName!);\n    if (!subCommandConfig || !(subCommandConfig.parser instanceof ArgParser)) {\n      // This should ideally not be reached if addSubCommand validated the parser instance\n      throw new ArgParserError(\n        `Internal error: Subcommand '${subCommandName!}' is misconfigured or its parser is not a valid ArgParser instance.`,\n        commandChainSoFar,\n      );\n    }\n    const nextParser = subCommandConfig.parser;\n    const nextArgs = argsToParse.slice(subCommandIndex + 1);\n    const nextCommandChain = [...commandChainSoFar, subCommandName];\n    const combinedArgsForNextLevel = {\n      ...accumulatedParentArgs,\n      ...currentLevelArgs,\n    };\n\n    return this._parseRecursive(\n      nextArgs,\n      nextParser,\n      combinedArgsForNextLevel,\n      nextCommandChain,\n      options,\n    );\n  }\n\n  #parseFlags(\n    args: string[],\n    options?: IParseOptions,\n  ): {\n    parsedArgs: TParsedArgs<ProcessedFlag[]>;\n    firstUnconsumedIndex: number;\n  } {\n    const flags = this.#flagManager.flags;\n\n    const output: TParsedArgs<ProcessedFlag[]> = Object.fromEntries(\n      flags.map((flag) => [\n        flag[\"name\"],\n        flag[\"allowMultiple\"] ? [] : undefined,\n      ]),\n    ) as TParsedArgs<ProcessedFlag[]>;\n\n    let consumedIndices = new Set<number>();\n\n    for (const flagToCheck of flags) {\n      if (flagToCheck[\"allowLigature\"] && !flagToCheck[\"flagOnly\"]) {\n        const regex = createRegExp(\n          anyOf(\n            ...flagToCheck[\"options\"].map((option: string) => `${option}=`),\n          ),\n          oneOrMore(char).groupedAs(\"arg\"),\n        );\n        for (let i = 0; i < args.length; i++) {\n          if (consumedIndices.has(i)) continue;\n          const itemToCheck = args[i];\n          const matches = regex.exec(`${itemToCheck}`);\n          if (matches?.groups?.[\"arg\"]) {\n            this._addToOutput(\n              flagToCheck,\n              matches?.groups?.[\"arg\"],\n              output,\n              options,\n            );\n            consumedIndices.add(i);\n            if (!flagToCheck[\"allowMultiple\"]) break;\n          }\n        }\n      }\n    }\n\n    for (const flagToCheck of flags) {\n      for (let index = 0; index < args.length; index++) {\n        if (consumedIndices.has(index)) continue;\n\n        const value = args[index];\n        const nextIndex = index + 1;\n        const nextValueExists = nextIndex < args.length;\n        const nextValue = nextValueExists ? args[nextIndex] : undefined;\n        const nextValueIsFlag =\n          typeof nextValue === \"string\" && nextValue.startsWith(\"-\");\n\n        if (flagToCheck[\"options\"].includes(value)) {\n          // Mark the flag itself as consumed immediately\n          consumedIndices.add(index);\n\n          if (flagToCheck[\"flagOnly\"]) {\n            this._addToOutput(flagToCheck, true, output, options);\n          } else if (nextValueExists && !nextValueIsFlag) {\n            this._addToOutput(flagToCheck, nextValue, output, options);\n            consumedIndices.add(nextIndex);\n          } else if (flagToCheck[\"type\"] === Boolean) {\n            this._addToOutput(flagToCheck, true, output, options);\n          }\n          if (!flagToCheck[\"allowMultiple\"]) break;\n        }\n      }\n    }\n\n    let firstUnconsumedIndex = args.length;\n    for (let i = 0; i < args.length; i++) {\n      if (!consumedIndices.has(i)) {\n        firstUnconsumedIndex = i;\n        break;\n      }\n    }\n\n    return { parsedArgs: output, firstUnconsumedIndex };\n  }\n\n  helpText(): string {\n    const cyan = chalk.cyan;\n    const green = chalk.green;\n    const white = chalk.white;\n    const red = chalk.red;\n    const dim = chalk.dim;\n\n    let rootAppName = this.#appName;\n    let current: ArgParser | undefined = this;\n    while (current.#parentParser) {\n      current = current.#parentParser;\n    }\n    if (current) {\n      rootAppName = current.#appName;\n    }\n\n    const helpTitle = this.#subCommandName\n      ? `${rootAppName} ${this.#subCommandName}`\n      : rootAppName;\n\n    let help = `${cyan(`${helpTitle} Help`)} (${this.#parameters.mandatoryCharacter} = Mandatory fields):\\n\\n`;\n\n    // ---- BEGIN ADDED DIAGNOSTIC LOG ----\n    // console.log(\n    //   `[ArgParser helpText Debug] 'this' context: constructor.name = ${this?.constructor?.name}, is ArgParser instance = ${this instanceof ArgParser}, subCommandName = ${this.#subCommandName || '(root)'}`,\n    // );\n    // ---- END ADDED DIAGNOSTIC LOG ----\n\n    if (this.#description) {\n      help += `${white(this.#description)}\\n\\n`;\n    }\n\n    const indent = (level: number = 1) => \"  \".repeat(level);\n\n    if (this.#subCommands.size > 0) {\n      // Use Map.size\n      help += `${cyan(\"Available sub-commands:\")}\\n`;\n      // Iterate over Map entries, then sort\n      help += Array.from(this.#subCommands.entries())\n        .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))\n        .map(([name, subCommandConfig]) => {\n          // subCommandConfig is an ISubCommand object from the map\n          const actualSubParserInstance = subCommandConfig.parser;\n\n          // Guard against misconfiguration, though addSubCommand should prevent non-ArgParser instances\n          if (!(actualSubParserInstance instanceof ArgParser)) {\n            return `${indent()}${green(name.padEnd(20))} [Error: Subcommand '${name}' has an invalid parser configuration]`;\n          }\n\n          let subHelp = `${indent()}${green(name.padEnd(20))} ${white(actualSubParserInstance.#description || \"\")}`;\n\n          const flagsFromSubManager =\n            actualSubParserInstance && actualSubParserInstance.#flagManager\n              ? actualSubParserInstance.#flagManager.flags\n              : undefined;\n          const subFlags = (flagsFromSubManager || []).filter(\n            (f: ProcessedFlag) => f[\"name\"] !== \"help\",\n          );\n          if (subFlags.length > 0) {\n            subHelp += `\\n${indent(2)}${dim(\"Flags:\")}`;\n            subFlags\n              .sort((a: ProcessedFlag, b: ProcessedFlag) =>\n                a[\"name\"].localeCompare(b[\"name\"]),\n              )\n              .forEach((f: ProcessedFlag) => {\n                const flagOptions = f[\"options\"]\n                  .map((opt: string) => green(opt))\n                  .join(\", \");\n                const flagDesc = Array.isArray(f[\"description\"])\n                  ? f[\"description\"][0]\n                  : f[\"description\"];\n                subHelp += `\\n${indent(3)}${flagOptions} - ${dim(flagDesc)}`;\n              });\n          } else {\n            subHelp += `\\n${indent(2)}${dim(\"Flags:\")} none`;\n          }\n\n          const subSubCommandNames = Array.from(\n            actualSubParserInstance.#subCommands.keys(),\n          ); // Get keys from actualSubParserInstance's Map\n          if (subSubCommandNames.length > 0) {\n            subHelp += `\\n${indent(2)}${dim(\"Sub-commands:\")} ${subSubCommandNames.join(\", \")}`;\n          } else {\n            subHelp += `\\n${indent(2)}${dim(\"Sub-commands:\")} none`;\n          }\n\n          return subHelp;\n        })\n        .join(\"\\n\\n\");\n      help += \"\\n\";\n    }\n\n    help += `\\n${cyan(\"Flags:\")}\\n`;\n    const localFlags = this.#flagManager.flags; // Use FlagManager for local flags\n    if (localFlags.length > 0) {\n      help += localFlags\n        .sort((flagA, flagB) => flagA[\"name\"].localeCompare(flagB[\"name\"]))\n        .map((flag: ProcessedFlag) => {\n          // Flag type is ProcessedFlag\n          const optionsText = flag[\"options\"]\n            .toSorted((a: string, b: string) => a.length - b.length) // Sort by length (shortest first)\n            .map((opt: string) => green(opt))\n            .join(\", \");\n          const isMandatory =\n            typeof flag.mandatory === \"function\" ? \"dynamic\" : flag.mandatory;\n          const mandatoryIndicator =\n            isMandatory === true\n              ? ` ${red(this.#parameters.mandatoryCharacter)}`\n              : isMandatory === \"dynamic\"\n                ? ` ${dim(\"(conditionally mandatory)\")}`\n                : \"\";\n\n          const descriptionLines = Array.isArray(flag[\"description\"])\n            ? flag[\"description\"]\n            : [flag[\"description\"]];\n\n          const metaLines: string[] = [];\n\n          // Determine the type name for display\n          let typeName = \"unknown\";\n          if (typeof flag[\"type\"] === \"function\") {\n            typeName = flag[\"type\"].name || \"custom function\";\n            // Make the type names more user-friendly\n            if (typeName === \"Boolean\") typeName = \"boolean\";\n            if (typeName === \"String\") typeName = \"string\";\n            if (typeName === \"Number\") typeName = \"number\";\n            if (typeName === \"Array\") typeName = \"array\";\n            if (typeName === \"Object\") typeName = \"object\";\n          } else if (typeof flag[\"type\"] === \"string\") {\n            typeName = flag[\"type\"];\n          }\n\n          metaLines.push(`Type: ${typeName}`);\n\n          if (flag[\"flagOnly\"]) {\n            metaLines.push(\"Flag only (no value expected)\");\n          }\n          if (\n            flag[\"defaultValue\"] !== undefined &&\n            flag[\"defaultValue\"] !== null\n          ) {\n            metaLines.push(`Default: ${JSON.stringify(flag[\"defaultValue\"])}`);\n          }\n          if (flag[\"enum\"] && flag[\"enum\"].length > 0) {\n            metaLines.push(\n              `Allowed values: ${flag[\"enum\"].map((v: any) => `'${v}'`).join(\", \")}`,\n            );\n          }\n\n          const maxOptionLength = Math.max(\n            ...localFlags.map(\n              (f: ProcessedFlag) => f[\"options\"].join(\", \").length,\n            ),\n            0,\n          );\n          const formattedOptions =\n            optionsText.padEnd(maxOptionLength + 5) + mandatoryIndicator;\n\n          return `\n${indent()}${formattedOptions}\n${indent(2)}${white(descriptionLines[0])}\n${metaLines.map((line) => `${indent(3)}${dim(line)}`).join(\"\\n\")}\n${descriptionLines\n  .slice(1)\n  .map((line) => `\\n${indent(2)}${white(line)}`)\n  .join(\"\")}\n  `.trim();\n        })\n        .join(\"\\n\\n\");\n    } else {\n      help += `${indent()}${dim(\"none\")}`;\n    }\n\n    return help;\n  }\n\n  public getSubCommand(name: string): ISubCommand | undefined {\n    return this.#subCommands.get(name);\n  }\n\n  public hasFlag(name: string): boolean {\n    // Delegates to FlagManager\n    return this.#flagManager.hasFlag(name);\n  }\n\n  public getCommandChain(): string[] {\n    const chain = [];\n    let currentParser: ArgParser | undefined = this;\n    while (currentParser && currentParser.#parentParser) {\n      chain.unshift(currentParser.#subCommandName);\n      currentParser = currentParser.#parentParser;\n    }\n    return chain;\n  }\n\n  public getLastParseResult(): TParsedArgs<ProcessedFlag[]> {\n    return this.#lastParseResult;\n  }\n\n  #displayErrorAndExit(error: ArgParserError): void {\n    let commandNameToSuggest = \"your-script\";\n\n    if (this.#appCommandName) {\n      commandNameToSuggest = this.#appCommandName;\n    } else if (this.#appName && this.#appName !== \"Argument Parser\") {\n      commandNameToSuggest = this.#appName;\n    } else if (\n      typeof process !== \"undefined\" &&\n      process.argv &&\n      process.argv[1]\n    ) {\n      try {\n        commandNameToSuggest = path.basename(process.argv[1]);\n      } catch {}\n    }\n\n    const commandPath = [\n      commandNameToSuggest,\n      ...(error.commandChain || []),\n    ].join(\" \");\n\n    console.error(`\\n${chalk.red.bold(\"Error:\")} ${error.message}`);\n    console.error(\n      `\\n${chalk.dim(`Try '${commandPath} --help' for usage details.`)}`,\n    );\n\n    if (typeof process === \"object\" && typeof process.exit === \"function\") {\n      process.exit(1 as never);\n    } else {\n      throw error;\n    }\n  }\n\n  #_printRecursiveToConsole(\n    parser: ArgParser,\n    level: number,\n    visited: Set<ArgParser> = new Set(),\n  ): void {\n    const indent = \"  \".repeat(level);\n    const subIndent = \"  \".repeat(level + 1);\n    const flagIndent = \"  \".repeat(level + 2);\n\n    console.log(\n      `${indent}Parser: ${chalk.blueBright(parser.#subCommandName || parser.#appName)}`,\n    );\n    if (parser.#description) {\n      console.log(`${subIndent}Description: ${parser.#description}`);\n    }\n    console.log(`${subIndent}Options:`);\n    console.log(`${flagIndent}appName: ${parser.#appName}`);\n    console.log(\n      `${flagIndent}appCommandName: ${parser.#appCommandName ?? chalk.dim(\"undefined\")}`,\n    );\n    console.log(`${flagIndent}handleErrors: ${parser.#handleErrors}`);\n    console.log(\n      `${flagIndent}throwForDuplicateFlags: ${parser.#throwForDuplicateFlags}`,\n    );\n    console.log(\n      `${flagIndent}inheritParentFlags: ${parser.#inheritParentFlags}`,\n    );\n    console.log(`${flagIndent}Handler Defined: ${!!parser.#handler}`);\n    console.log(\n      `${subIndent}Internal Params: ${JSON.stringify(parser.#parameters)}`,\n    );\n\n    const flags = parser.#flagManager.flags;\n    if (flags.length > 0) {\n      console.log(`${subIndent}Flags (${flags.length}):`);\n      flags.forEach((flag: ProcessedFlag) => {\n        console.log(`${flagIndent}* ${chalk.green(flag[\"name\"])}:`);\n        console.log(`${flagIndent}  Options: ${flag[\"options\"].join(\", \")}`);\n        console.log(\n          `${flagIndent}  Description: ${Array.isArray(flag[\"description\"]) ? flag[\"description\"].join(\" | \") : flag[\"description\"]}`,\n        );\n        console.log(\n          `${flagIndent}  Type: ${typeof flag[\"type\"] === \"function\" ? flag[\"type\"].name || \"custom function\" : flag[\"type\"]}`,\n        );\n        console.log(\n          `${flagIndent}  Mandatory: ${typeof flag[\"mandatory\"] === \"function\" ? \"dynamic\" : (flag[\"mandatory\"] ?? false)}`,\n        );\n        console.log(\n          `${flagIndent}  Default: ${JSON.stringify(flag[\"defaultValue\"])}`,\n        );\n        console.log(`${flagIndent}  Flag Only: ${flag[\"flagOnly\"]}`);\n        console.log(`${flagIndent}  Allow Multiple: ${flag[\"allowMultiple\"]}`);\n        console.log(`${flagIndent}  Allow Ligature: ${flag[\"allowLigature\"]}`);\n        console.log(\n          `${flagIndent}  Enum: ${flag[\"enum\"] && flag[\"enum\"].length > 0 ? flag[\"enum\"].join(\", \") : \"none\"}`,\n        );\n        console.log(`${flagIndent}  Validator Defined: ${!!flag[\"validate\"]}`);\n      });\n    } else {\n      console.log(`${subIndent}Flags: ${chalk.dim(\"none\")}`);\n    }\n\n    const subCommandParsers = Array.from(parser.#subCommands.values());\n    if (subCommandParsers.length > 0) {\n      console.log(`${subIndent}Sub-Commands (${subCommandParsers.length}):`);\n      subCommandParsers.forEach((subCommand: any) => {\n        this.#_printRecursiveToConsole(subCommand.parser, level + 1, visited);\n      });\n    } else {\n      console.log(`${subIndent}Sub-Commands: ${chalk.dim(\"none\")}`);\n    }\n  }\n\n  #_buildRecursiveString(\n    parser: ArgParser,\n    level: number,\n    visited = new Set<ArgParser>(),\n  ): string {\n    // Add visited set\n    if (visited.has(parser)) return \"\"; // Prevent infinite loops for circular structures (if ever possible)\n    visited.add(parser);\n\n    let output = \"\";\n    const indent = \"  \".repeat(level);\n    const subIndent = \"  \".repeat(level + 1);\n    const flagIndent = \"  \".repeat(level + 2);\n\n    const addLine = (line: string) => {\n      output += line + \"\\\\n\";\n    };\n\n    addLine(\n      `${indent}Parser: ${parser.#subCommandName || parser.#appName}`, // #appName is guaranteed\n    );\n    if (parser.#description) {\n      addLine(`${subIndent}Description: ${parser.#description}`);\n    }\n    addLine(`${subIndent}Options:`);\n    addLine(`${flagIndent}appName: ${parser.#appName}`);\n    addLine(\n      `${flagIndent}appCommandName: ${parser.#appCommandName ?? \"undefined\"}`,\n    );\n    addLine(`${flagIndent}handleErrors: ${parser.#handleErrors}`);\n    addLine(\n      `${flagIndent}throwForDuplicateFlags: ${parser.#throwForDuplicateFlags}`,\n    );\n    addLine(`${flagIndent}inheritParentFlags: ${parser.#inheritParentFlags}`);\n    addLine(`${flagIndent}Handler Defined: ${!!parser.#handler}`);\n    addLine(\n      `${subIndent}Internal Params: ${JSON.stringify(parser.#parameters)}`,\n    );\n\n    const flags = parser.#flagManager.flags;\n    if (flags.length > 0) {\n      addLine(`${subIndent}Flags (${flags.length}):`);\n      flags.forEach((flag: ProcessedFlag) => {\n        addLine(`${flagIndent}* ${flag[\"name\"]}:`);\n        addLine(`${flagIndent}  Options: ${flag[\"options\"].join(\", \")}`);\n        addLine(\n          `${flagIndent}  Description: ${Array.isArray(flag[\"description\"]) ? flag[\"description\"].join(\" | \") : flag[\"description\"]}`,\n        );\n        let typeName = \"unknown\";\n        if (typeof flag[\"type\"] === \"function\") {\n          typeName = flag[\"type\"].name || \"custom function\";\n        } else if (typeof flag[\"type\"] === \"string\") {\n          typeName = flag[\"type\"];\n        } else if (typeof flag[\"type\"] === \"object\" && flag[\"type\"]) {\n          try {\n            typeName = (flag[\"type\"] as any).constructor?.name || \"object\";\n          } catch {\n            typeName = \"object\";\n          }\n        }\n        addLine(`${flagIndent}  Type: ${typeName}`);\n        addLine(\n          `${flagIndent}  Mandatory: ${typeof flag[\"mandatory\"] === \"function\" ? \"dynamic\" : (flag[\"mandatory\"] ?? false)}`,\n        );\n        addLine(\n          `${flagIndent}  Default: ${JSON.stringify(flag[\"defaultValue\"])}`,\n        );\n        addLine(`${flagIndent}  Flag Only: ${flag[\"flagOnly\"]}`);\n        addLine(`${flagIndent}  Allow Multiple: ${flag[\"allowMultiple\"]}`);\n        addLine(`${flagIndent}  Allow Ligature: ${flag[\"allowLigature\"]}`);\n        addLine(\n          `${flagIndent}  Enum: ${flag[\"enum\"] && flag[\"enum\"].length > 0 ? flag[\"enum\"].join(\", \") : \"none\"}`,\n        );\n        addLine(`${flagIndent}  Validator Defined: ${!!flag[\"validate\"]}`);\n      });\n    } else {\n      addLine(`${subIndent}Flags: none`);\n    }\n\n    const subCommandParsers = Array.from(parser.#subCommands.values());\n    if (subCommandParsers.length > 0) {\n      addLine(`${subIndent}Sub-Commands (${subCommandParsers.length}):`);\n      subCommandParsers.forEach((subCommand: any) => {\n        output += this.#_buildRecursiveString(\n          subCommand.parser,\n          level + 1,\n          visited,\n        );\n      });\n    } else {\n      addLine(`${subIndent}Sub-Commands: none`);\n    }\n    return output;\n  }\n\n  #_buildRecursiveJson(\n    parser: ArgParser,\n    visited = new Set<ArgParser>(),\n  ): object {\n    if (visited.has(parser))\n      return {\n        note: `Reference to already processed parser: ${parser.#subCommandName || parser.#appName}`,\n      };\n    visited.add(parser);\n\n    const config: any = {\n      parserName: parser.#subCommandName || parser.#appName, // #appName is guaranteed\n      description: parser.#description,\n      options: {\n        appName: parser.#appName,\n        appCommandName: parser.#appCommandName ?? undefined,\n        handleErrors: parser.#handleErrors,\n        throwForDuplicateFlags: parser.#throwForDuplicateFlags,\n        inheritParentFlags: parser.#inheritParentFlags,\n      },\n      handlerDefined: !!parser.#handler,\n      internalParams: parser.#parameters,\n      flags: [],\n      subCommands: {}, // Will be an object where keys are sub-command names\n    };\n\n    const flags = parser.#flagManager.flags;\n    config.flags = flags.map((flag: ProcessedFlag) => {\n      let typeName = \"unknown\";\n      if (typeof flag[\"type\"] === \"function\") {\n        typeName = flag[\"type\"].name || \"custom function\";\n      } else if (typeof flag[\"type\"] === \"string\") {\n        typeName = flag[\"type\"];\n      } else if (typeof flag[\"type\"] === \"object\" && flag[\"type\"]) {\n        try {\n          typeName = (flag[\"type\"] as any).constructor?.name || \"object\";\n        } catch {\n          typeName = \"object\";\n        }\n      }\n\n      return {\n        name: flag[\"name\"],\n        options: flag[\"options\"],\n        description: flag[\"description\"],\n        type: typeName,\n        mandatory:\n          typeof flag[\"mandatory\"] === \"function\"\n            ? \"dynamic\"\n            : (flag[\"mandatory\"] ?? false),\n        defaultValue: flag[\"defaultValue\"],\n        flagOnly: flag[\"flagOnly\"],\n        allowMultiple: flag[\"allowMultiple\"],\n        allowLigature: flag[\"allowLigature\"],\n        enum: flag[\"enum\"],\n        validatorDefined: !!flag[\"validate\"],\n      };\n    });\n\n    const subCommands = Array.from(parser.#subCommands.values());\n    if (subCommands.length > 0) {\n      subCommands.forEach((sub: any) => {\n        config.subCommands[sub.name] = this.#_buildRecursiveJson(\n          sub.parser,\n          visited,\n        );\n      });\n    }\n\n    return config;\n  }\n}\n"],"names":["path","zodFlagSchema","z","val","value","obj","newObj","_FlagManager","options","initialFlags","__privateAdd","__flags","_throwForDuplicateFlags","__privateSet","flag","parsedFromZod","resolvedType","inputTypeFromZod","safeFlag","__privateGet","processedFlag","flags","name","FlagManager","ArgParserError","message","cmdChain","_ArgParser","_ArgParser_instances","_appName","_appCommandName","_subCommandName","_parameters","_handler","_description","_handleErrors","_parentParser","_lastParseResult","_inheritParentFlags","_subCommands","_flagManager","helpFlag","_value","_parsedArgs","sub","arg","output","_parseOptions","allowedValues","v","chalk","validationResult","subCommandConfig","subParser","parentFlags","parentFlag","handler","filePath","dir","fs","outputObject","__privateMethod","_buildRecursiveJson_fn","jsonString","plainText","_buildRecursiveString_fn","error","_printRecursiveToConsole_fn","processArgs","_handleGlobalChecks_fn","identifiedFinalParser","identifiedCommandChain","identifiedParserChain","_identifyCommandChainAndParsers_fn","finalArgs","handlerToExecute","_validateMandatoryFlags_fn","_applyDefaultValues_fn","_prepareAndExecuteHandler_fn","displayErrorAndExit_fn","argsToParse","currentParser","accumulatedParentArgs","commandChainSoFar","subCommandIndex","subCommandName","i","potentialSubCommand","argsForCurrentLevel","currentLevelArgs","firstUnconsumedIndex","_a","parseFlags_fn","_b","combinedArgsFromThisAndParents","unknownCommand","finalParseResultArgs","nextParser","nextArgs","nextCommandChain","combinedArgsForNextLevel","cyan","green","white","red","dim","rootAppName","current","helpTitle","help","indent","level","nameA","nameB","actualSubParserInstance","subHelp","subFlags","f","a","b","flagOptions","opt","flagDesc","subSubCommandNames","localFlags","flagA","flagB","optionsText","isMandatory","mandatoryIndicator","descriptionLines","metaLines","typeName","maxOptionLength","formattedOptions","line","chain","parserChainSoFar","nextParserChain","_identifiedParserChain","remainingArgs","accumulatedArgs","parsingSteps","rootSubCommandIndex","rootArgsSlice","rootParsedArgs","e","nextSubCommandIndex","currentLevelArgsSlice","stepInfo","currentLevelParsedArgs","_c","step","parserNameForLog","_d","helpFlagDefinition","helpOptions","parserChain","commandChain","finalMandatoryFlagsMissing","checkedFlagNames","parser","currentCommandChain","currentFlagIsMissing","finalParser","flagName","skipHandlers","finalParserWhoseHandlerWillRun","finalParserFlags","handlerArgs","args","consumedIndices","flagToCheck","regex","createRegExp","anyOf","option","oneOrMore","char","itemToCheck","matches","index","nextIndex","nextValueExists","nextValue","nextValueIsFlag","commandNameToSuggest","commandPath","visited","subIndent","flagIndent","subCommandParsers","subCommand","addLine","config","subCommands","ArgParser"],"mappings":"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"}